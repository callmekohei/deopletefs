
namespace dummyJson

module dummy =
    let dummy =
        Map.ofSeq [
            "OneWordHint","""{"word":"Choice1Of2","info":[["union case Choice.Choice1Of2: 'T1 -> Choice<'T1,'T2>"]]}""" + "\n" + """{"word":"Choice1Of3","info":[["union case Choice.Choice1Of3: 'T1 -> Choice<'T1,'T2,'T3>"]]}""" + "\n" + """{"word":"Choice1Of4","info":[["union case Choice.Choice1Of4: 'T1 -> Choice<'T1,'T2,'T3,'T4>"]]}""" + "\n" + """{"word":"Choice1Of5","info":[["union case Choice.Choice1Of5: 'T1 -> Choice<'T1,'T2,'T3,'T4,'T5>"]]}""" + "\n" + """{"word":"Choice1Of6","info":[["union case Choice.Choice1Of6: 'T1 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6>"]]}""" + "\n" + """{"word":"Choice1Of7","info":[["union case Choice.Choice1Of7: 'T1 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7>"]]}""" + "\n" + """{"word":"Choice2Of2","info":[["union case Choice.Choice2Of2: 'T2 -> Choice<'T1,'T2>"]]}""" + "\n" + """{"word":"Choice2Of3","info":[["union case Choice.Choice2Of3: 'T2 -> Choice<'T1,'T2,'T3>"]]}""" + "\n" + """{"word":"Choice2Of4","info":[["union case Choice.Choice2Of4: 'T2 -> Choice<'T1,'T2,'T3,'T4>"]]}""" + "\n" + """{"word":"Choice2Of5","info":[["union case Choice.Choice2Of5: 'T2 -> Choice<'T1,'T2,'T3,'T4,'T5>"]]}""" + "\n" + """{"word":"Choice2Of6","info":[["union case Choice.Choice2Of6: 'T2 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6>"]]}""" + "\n" + """{"word":"Choice2Of7","info":[["union case Choice.Choice2Of7: 'T2 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7>"]]}""" + "\n" + """{"word":"Choice3Of3","info":[["union case Choice.Choice3Of3: 'T3 -> Choice<'T1,'T2,'T3>"]]}""" + "\n" + """{"word":"Choice3Of4","info":[["union case Choice.Choice3Of4: 'T3 -> Choice<'T1,'T2,'T3,'T4>"]]}""" + "\n" + """{"word":"Choice3Of5","info":[["union case Choice.Choice3Of5: 'T3 -> Choice<'T1,'T2,'T3,'T4,'T5>"]]}""" + "\n" + """{"word":"Choice3Of6","info":[["union case Choice.Choice3Of6: 'T3 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6>"]]}""" + "\n" + """{"word":"Choice3Of7","info":[["union case Choice.Choice3Of7: 'T3 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7>"]]}""" + "\n" + """{"word":"Choice4Of4","info":[["union case Choice.Choice4Of4: 'T4 -> Choice<'T1,'T2,'T3,'T4>"]]}""" + "\n" + """{"word":"Choice4Of5","info":[["union case Choice.Choice4Of5: 'T4 -> Choice<'T1,'T2,'T3,'T4,'T5>"]]}""" + "\n" + """{"word":"Choice4Of6","info":[["union case Choice.Choice4Of6: 'T4 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6>"]]}""" + "\n" + """{"word":"Choice4Of7","info":[["union case Choice.Choice4Of7: 'T4 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7>"]]}""" + "\n" + """{"word":"Choice5Of5","info":[["union case Choice.Choice5Of5: 'T5 -> Choice<'T1,'T2,'T3,'T4,'T5>"]]}""" + "\n" + """{"word":"Choice5Of6","info":[["union case Choice.Choice5Of6: 'T5 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6>"]]}""" + "\n" + """{"word":"Choice5Of7","info":[["union case Choice.Choice5Of7: 'T5 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7>"]]}""" + "\n" + """{"word":"Choice6Of6","info":[["union case Choice.Choice6Of6: 'T6 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6>"]]}""" + "\n" + """{"word":"Choice6Of7","info":[["union case Choice.Choice6Of7: 'T6 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7>"]]}""" + "\n" + """{"word":"Choice7Of7","info":[["union case Choice.Choice7Of7: 'T7 -> Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7>"]]}""" + "\n" + """{"word":"Error","info":[["union case Result.Error: ErrorValue: 'TError -> Result<'T,'TError>"]]}""" + "\n" + """{"word":"Failure","info":[["val Failure : message:string -> exn"],["active recognizer Failure: exn -> string option"]]}""" + "\n" + """{"word":"MatchFailureException","info":[["exception MatchFailureException of string * int * int"]]}""" + "\n" + """{"word":"None","info":[["union case Option.None: Option<'T>"]]}""" + "\n" + """{"word":"Ok","info":[["union case Result.Ok: ResultValue: 'T -> Result<'T,'TError>"]]}""" + "\n" + """{"word":"Some","info":[["union case Option.Some: Value: 'T -> Option<'T>"]]}""" + "\n" + """{"word":"abs","info":[["val abs : value:'T -> 'T (requires member Abs)"]]}""" + "\n" + """{"word":"acos","info":[["val acos : value:'T -> 'T (requires member Acos)"]]}""" + "\n" + """{"word":"array2D","info":[["val array2D : rows:seq<#seq<'T>> -> 'T [,]"]]}""" + "\n" + """{"word":"asin","info":[["val asin : value:'T -> 'T (requires member Asin)"]]}""" + "\n" + """{"word":"async","info":[["val async : AsyncBuilder"]]}""" + "\n" + """{"word":"atan","info":[["val atan : value:'T -> 'T (requires member Atan)"]]}""" + "\n" + """{"word":"atan2","info":[["val atan2 : y:'T1 -> x:'T1 -> 'T2 (requires member Atan2)"]]}""" + "\n" + """{"word":"box","info":[["val box : value:'T -> obj"]]}""" + "\n" + """{"word":"byte","info":[["val byte : value:'T -> byte (requires member op_Explicit)"],["type byte = System.Byte"]]}""" + "\n" + """{"word":"ceil","info":[["val ceil : value:'T -> 'T (requires member Ceiling)"]]}""" + "\n" + """{"word":"char","info":[["val char : value:'T -> char (requires member op_Explicit)"],["type char = System.Char"]]}""" + "\n" + """{"word":"compare","info":[["val compare : e1:'T -> e2:'T -> int (requires comparison)"]]}""" + "\n" + """{"word":"cos","info":[["val cos : value:'T -> 'T (requires member Cos)"]]}""" + "\n" + """{"word":"cosh","info":[["val cosh : value:'T -> 'T (requires member Cosh)"]]}""" + "\n" + """{"word":"decimal","info":[["val decimal : value:'T -> decimal (requires member op_Explicit)"],["type decimal = System.Decimal"],["type decimal<'Measure> = decimal"]]}""" + "\n" + """{"word":"decr","info":[["val decr : cell:int ref -> unit"]]}""" + "\n" + """{"word":"defaultArg","info":[["val defaultArg : arg:'T option -> defaultValue:'T -> 'T"]]}""" + "\n" + """{"word":"dict","info":[["val dict : keyValuePairs:seq<'Key * 'Value> -> System.Collections.Generic.IDictionary<'Key,'Value> (requires equality)"]]}""" + "\n" + """{"word":"double","info":[["val double : value:'T -> double (requires member op_Explicit)"],["type double = System.Double"]]}""" + "\n" + """{"word":"enum","info":[["val enum : value:int32 -> 'U (requires enum)"]]}""" + "\n" + """{"word":"eprintf","info":[["val eprintf : format:Printf.TextWriterFormat<'T> -> 'T"]]}""" + "\n" + """{"word":"eprintfn","info":[["val eprintfn : format:Printf.TextWriterFormat<'T> -> 'T"]]}""" + "\n" + """{"word":"exit","info":[["val exit : exitcode:int -> 'T"]]}""" + "\n" + """{"word":"exp","info":[["val exp : value:'T -> 'T (requires member Exp)"]]}""" + "\n" + """{"word":"failwith","info":[["val failwith : message:string -> 'T"]]}""" + "\n" + """{"word":"failwithf","info":[["val failwithf : format:Printf.StringFormat<'T,'Result> -> 'T"]]}""" + "\n" + """{"word":"float","info":[["val float : value:'T -> float (requires member op_Explicit)"],["type float = System.Double"],["type float<'Measure> = float"]]}""" + "\n" + """{"word":"float32","info":[["val float32 : value:'T -> float32 (requires member op_Explicit)"],["type float32 = System.Single"],["type float32<'Measure> = float32"]]}""" + "\n" + """{"word":"floor","info":[["val floor : value:'T -> 'T (requires member Floor)"]]}""" + "\n" + """{"word":"fprintf","info":[["val fprintf : textWriter:System.IO.TextWriter -> format:Printf.TextWriterFormat<'T> -> 'T"]]}""" + "\n" + """{"word":"fprintfn","info":[["val fprintfn : textWriter:System.IO.TextWriter -> format:Printf.TextWriterFormat<'T> -> 'T"]]}""" + "\n" + """{"word":"fsi","info":[["val fsi : Compiler.Interactive.InteractiveSession"]]}""" + "\n" + """{"word":"fst","info":[["val fst : tuple:('T1 * 'T2) -> 'T1"]]}""" + "\n" + """{"word":"hash","info":[["val hash : obj:'T -> int (requires equality)"]]}""" + "\n" + """{"word":"id","info":[["val id : x:'T -> 'T"]]}""" + "\n" + """{"word":"ignore","info":[["val ignore : value:'T -> unit"]]}""" + "\n" + """{"word":"incr","info":[["val incr : cell:int ref -> unit"]]}""" + "\n" + """{"word":"infinity","info":[["val infinity : float"]]}""" + "\n" + """{"word":"infinityf","info":[["val infinityf : float32"]]}""" + "\n" + """{"word":"int","info":[["val int : value:'T -> int (requires member op_Explicit)"],["type int = int32"],["type int<'Measure> = int"]]}""" + "\n" + """{"word":"int16","info":[["val int16 : value:'T -> int16 (requires member op_Explicit)"],["type int16 = System.Int16"],["type int16<'Measure> = int16"]]}""" + "\n" + """{"word":"int32","info":[["val int32 : value:'T -> int32 (requires member op_Explicit)"],["type int32 = System.Int32"]]}""" + "\n" + """{"word":"int64","info":[["val int64 : value:'T -> int64 (requires member op_Explicit)"],["type int64 = System.Int64"],["type int64<'Measure> = int64"]]}""" + "\n" + """{"word":"int8","info":[["val int8 : value:'T -> int8 (requires member op_Explicit)"],["type int8 = System.SByte"]]}""" + "\n" + """{"word":"invalidArg","info":[["val invalidArg : argumentName:string -> message:string -> 'T"]]}""" + "\n" + """{"word":"invalidOp","info":[["val invalidOp : message:string -> 'T"]]}""" + "\n" + """{"word":"isNull","info":[["val isNull : value:'T -> bool (requires 'T : null)"]]}""" + "\n" + """{"word":"limitedHash","info":[["val limitedHash : limit:int -> obj:'T -> int (requires equality)"]]}""" + "\n" + """{"word":"lock","info":[["val lock : lockObject:'Lock -> action:(unit -> 'T) -> 'T (requires reference type)"]]}""" + "\n" + """{"word":"log","info":[["val log : value:'T -> 'T (requires member Log)"]]}""" + "\n" + """{"word":"log10","info":[["val log10 : value:'T -> 'T (requires member Log10)"]]}""" + "\n" + """{"word":"max","info":[["val max : e1:'T -> e2:'T -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"min","info":[["val min : e1:'T -> e2:'T -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"nan","info":[["val nan : float"]]}""" + "\n" + """{"word":"nanf","info":[["val nanf : float32"]]}""" + "\n" + """{"word":"nativeint","info":[["val nativeint : value:'T -> nativeint (requires member op_Explicit)"],["type nativeint = System.IntPtr"]]}""" + "\n" + """{"word":"not","info":[["val not : value:bool -> bool"]]}""" + "\n" + """{"word":"nullArg","info":[["val nullArg : argumentName:string -> 'T"]]}""" + "\n" + """{"word":"pown","info":[["val pown : x:'T -> n:int -> 'T (requires member get_One and member ( * ) and member ( / ))"]]}""" + "\n" + """{"word":"printf","info":[["val printf : format:Printf.TextWriterFormat<'T> -> 'T"]]}""" + "\n" + """{"word":"printfn","info":[["val printfn : format:Printf.TextWriterFormat<'T> -> 'T"]]}""" + "\n" + """{"word":"query","info":[["val query : Linq.QueryBuilder"]]}""" + "\n" + """{"word":"raise","info":[["val raise : exn:System.Exception -> 'T"]]}""" + "\n" + """{"word":"ref","info":[["val ref : value:'T -> 'T ref"],["type 'T ref = Ref<'T>"]]}""" + "\n" + """{"word":"reraise","info":[["val reraise : unit -> 'T"]]}""" + "\n" + """{"word":"round","info":[["val round : value:'T -> 'T (requires member Round)"]]}""" + "\n" + """{"word":"sbyte","info":[["val sbyte : value:'T -> sbyte (requires member op_Explicit)"],["type sbyte = System.SByte"],["type sbyte<'Measure> = sbyte"]]}""" + "\n" + """{"word":"seq","info":[["val seq : sequence:seq<'T> -> seq<'T>"],["type seq<'T> = System.Collections.Generic.IEnumerable<'T>"]]}""" + "\n" + """{"word":"set","info":[["val set : elements:seq<'T> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"sign","info":[["val sign : value:'T -> int (requires member get_Sign)"]]}""" + "\n" + """{"word":"sin","info":[["val sin : value:'T -> 'T (requires member Sin)"]]}""" + "\n" + """{"word":"single","info":[["val single : value:'T -> single (requires member op_Explicit)"],["type single = System.Single"]]}""" + "\n" + """{"word":"sinh","info":[["val sinh : value:'T -> 'T (requires member Sinh)"]]}""" + "\n" + """{"word":"sizeof","info":[["val sizeof<'T> : int"]]}""" + "\n" + """{"word":"snd","info":[["val snd : tuple:('T1 * 'T2) -> 'T2"]]}""" + "\n" + """{"word":"sprintf","info":[["val sprintf : format:Printf.StringFormat<'T> -> 'T"]]}""" + "\n" + """{"word":"sqrt","info":[["val sqrt : value:'T -> 'U (requires member Sqrt)"]]}""" + "\n" + """{"word":"stderr","info":[["val stderr<'T> : System.IO.TextWriter"]]}""" + "\n" + """{"word":"stdin","info":[["val stdin<'T> : System.IO.TextReader"]]}""" + "\n" + """{"word":"stdout","info":[["val stdout<'T> : System.IO.TextWriter"]]}""" + "\n" + """{"word":"string","info":[["val string : value:'T -> string"],["type string = System.String"]]}""" + "\n" + """{"word":"tan","info":[["val tan : value:'T -> 'T (requires member Tan)"]]}""" + "\n" + """{"word":"tanh","info":[["val tanh : value:'T -> 'T (requires member Tanh)"]]}""" + "\n" + """{"word":"truncate","info":[["val truncate : value:'T -> 'T (requires member Truncate)"]]}""" + "\n" + """{"word":"tryUnbox","info":[["val tryUnbox : value:obj -> 'T option"]]}""" + "\n" + """{"word":"typedefof","info":[["val typedefof<'T> : System.Type"]]}""" + "\n" + """{"word":"typeof","info":[["val typeof<'T> : System.Type"]]}""" + "\n" + """{"word":"uint16","info":[["val uint16 : value:'T -> uint16 (requires member op_Explicit)"],["type uint16 = System.UInt16"]]}""" + "\n" + """{"word":"uint32","info":[["val uint32 : value:'T -> uint32 (requires member op_Explicit)"],["type uint32 = System.UInt32"]]}""" + "\n" + """{"word":"uint64","info":[["val uint64 : value:'T -> uint64 (requires member op_Explicit)"],["type uint64 = System.UInt64"]]}""" + "\n" + """{"word":"uint8","info":[["val uint8 : value:'T -> uint8 (requires member op_Explicit)"],["type uint8 = System.Byte"]]}""" + "\n" + """{"word":"unativeint","info":[["val unativeint : value:'T -> unativeint (requires member op_Explicit)"],["type unativeint = System.UIntPtr"]]}""" + "\n" + """{"word":"unbox","info":[["val unbox : value:obj -> 'T"]]}""" + "\n" + """{"word":"using","info":[["val using : resource:'T -> action:('T -> 'U) -> 'U (requires 'T :> System.IDisposable)"]]}""" + "\n" + """{"word":"|Failure|_|","info":[["val ( |Failure|_| ) : error:exn -> string option"]]}""" + "\n" + """{"word":"|KeyValue|","info":[["val ( |KeyValue| ) : keyValuePair:System.Collections.Generic.KeyValuePair<'Key,'Value> -> 'Key * 'Value"]]}""" + "\n" + """{"word":"|Lazy|","info":[["val ( |Lazy| ) : input:Lazy<'T> -> 'T"]]}""" + "\n" + """{"word":"Lazy","info":[["active recognizer Lazy: Lazy<'T> -> 'T"],["type Lazy<'T> = System.Lazy<'T>"]]}""" + "\n" + """{"word":"KeyValue","info":[["active recognizer KeyValue: System.Collections.Generic.KeyValuePair<'Key,'Value> -> 'Key * 'Value"]]}""" + "\n" + """{"word":"Array","info":[["module Array\n\nfrom Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"Array2D","info":[["module Array2D\n\nfrom Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"Array3D","info":[["module Array3D\n\nfrom Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"Array4D","info":[["module Array4D\n\nfrom Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"Checked","info":[["module Checked\n\nfrom Microsoft.FSharp.Core.Operators"],["module Checked\n\nfrom Microsoft.FSharp.Core.ExtraTopLevelOperators"]]}""" + "\n" + """{"word":"Collections","info":[["namespace Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"CommonExtensions","info":[["module CommonExtensions\n\nfrom Microsoft.FSharp.Control"]]}""" + "\n" + """{"word":"ComparisonIdentity","info":[["module ComparisonIdentity\n\nfrom Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"CompilerServices","info":[["namespace Microsoft.FSharp.Core.CompilerServices"]]}""" + "\n" + """{"word":"Control","info":[["namespace Microsoft.FSharp.Control"]]}""" + "\n" + """{"word":"Core","info":[["namespace Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"Data","info":[["namespace Microsoft.FSharp.Data"]]}""" + "\n" + """{"word":"Event","info":[["module Event\n\nfrom Microsoft.FSharp.Control"],["type Event<'T> =\n  new : unit -> Event<'T>\n  member Trigger : arg:'T -> unit\n  member Publish : IEvent<'T>"],["type Event<'Delegate,'Args (requires delegate and 'Delegate :> Delegate)> =\n  new : unit -> Event<'Delegate,'Args>\n  member Trigger : sender:obj * args:'Args -> unit\n  member Publish : IEvent<'Delegate,'Args>"],["new : unit -> Event<'T>"],["new : unit -> Event<'Delegate,'Args>"]]}""" + "\n" + """{"word":"ExtraTopLevelOperators","info":[["module ExtraTopLevelOperators\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"FSInteractiveSettings","info":[["namespace FSInteractiveSettings"]]}""" + "\n" + """{"word":"FSharp","info":[["namespace Microsoft.FSharp"]]}""" + "\n" + """{"word":"HashIdentity","info":[["module HashIdentity\n\nfrom Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"LanguagePrimitives","info":[["module LanguagePrimitives\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"LazyExtensions","info":[["module LazyExtensions\n\nfrom Microsoft.FSharp.Control"]]}""" + "\n" + """{"word":"Linq","info":[["namespace Microsoft.FSharp.Linq"]]}""" + "\n" + """{"word":"List","info":[["module List\n\nfrom Microsoft.FSharp.Collections"],["type List<'T> =\n  | ( [] )\n  | ( :: ) of Head: 'T * Tail: 'T list\n    interface IReadOnlyCollection<'T>\n    interface IEnumerable\n    interface IEnumerable<'T>\n    member GetSlice : startIndex:int option * endIndex:int option -> 'T list\n    member Head : 'T\n    member IsEmpty : bool\n    member Item : index:int -> 'T with get\n    member Length : int\n    member Tail : 'T list\n    static member Cons : head:'T * tail:'T list -> 'T list\n    ..."]]}""" + "\n" + """{"word":"Map","info":[["module Map\n\nfrom Microsoft.FSharp.Collections"],["type Map<'Key,'Value (requires comparison)> =\n  interface IEnumerable\n  interface IComparable\n  interface IEnumerable<KeyValuePair<'Key,'Value>>\n  interface ICollection<KeyValuePair<'Key,'Value>>\n  interface IDictionary<'Key,'Value>\n  new : elements:seq<'Key * 'Value> -> Map<'Key,'Value>\n  member Add : key:'Key * value:'Value -> Map<'Key,'Value>\n  member ContainsKey : key:'Key -> bool\n  override Equals : obj -> bool\n  member Remove : key:'Key -> Map<'Key,'Value>\n  ..."],["new : elements:seq<'Key * 'Value> -> Map<'Key,'Value>"]]}""" + "\n" + """{"word":"Microsoft","info":[["namespace Microsoft"]]}""" + "\n" + """{"word":"Mono","info":[["namespace Mono"]]}""" + "\n" + """{"word":"NativeInterop","info":[["namespace Microsoft.FSharp.NativeInterop"]]}""" + "\n" + """{"word":"NonStructuralComparison","info":[["module NonStructuralComparison\n\nfrom Microsoft.FSharp.Core.Operators"]]}""" + "\n" + """{"word":"NumericLiteralI","info":[["module NumericLiteralI\n\nfrom Microsoft.FSharp.Core.NumericLiterals"]]}""" + "\n" + """{"word":"NumericLiterals","info":[["module NumericLiterals\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"Observable","info":[["module Observable\n\nfrom Microsoft.FSharp.Control"]]}""" + "\n" + """{"word":"OperatorIntrinsics","info":[["module OperatorIntrinsics\n\nfrom Microsoft.FSharp.Core.Operators"]]}""" + "\n" + """{"word":"Operators","info":[["module Operators\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"OptimizedClosures","info":[["module OptimizedClosures\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"Option","info":[["module Option\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"Primitives","info":[["namespace Microsoft.FSharp.Primitives"]]}""" + "\n" + """{"word":"Printf","info":[["module Printf\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"Quotations","info":[["namespace Microsoft.FSharp.Quotations"]]}""" + "\n" + """{"word":"Reflection","info":[["namespace Microsoft.FSharp.Reflection"]]}""" + "\n" + """{"word":"Result","info":[["module Result\n\nfrom Microsoft.FSharp.Core"],["[<Struct>]\ntype Result<'T,'TError> =\n  | Ok of ResultValue: 'T\n  | Error of ErrorValue: 'TError"]]}""" + "\n" + """{"word":"Seq","info":[["module Seq\n\nfrom Microsoft.FSharp.Collections"]]}""" + "\n" + """{"word":"Set","info":[["module Set\n\nfrom Microsoft.FSharp.Collections"],["type Set<'T (requires comparison)> =\n  interface IComparable\n  interface IEnumerable\n  interface IEnumerable<'T>\n  interface ICollection<'T>\n  new : elements:seq<'T> -> Set<'T>\n  member Add : value:'T -> Set<'T>\n  member Contains : value:'T -> bool\n  override Equals : obj -> bool\n  member IsProperSubsetOf : otherSet:Set<'T> -> bool\n  member IsProperSupersetOf : otherSet:Set<'T> -> bool\n  ..."],["new : elements:seq<'T> -> Set<'T>"]]}""" + "\n" + """{"word":"String","info":[["module String\n\nfrom Microsoft.FSharp.Core"]]}""" + "\n" + """{"word":"System","info":[["namespace System"]]}""" + "\n" + """{"word":"Text","info":[["namespace Microsoft.FSharp.Text"]]}""" + "\n" + """{"word":"Unchecked","info":[["module Unchecked\n\nfrom Microsoft.FSharp.Core.Operators"]]}""" + "\n" + """{"word":"WebExtensions","info":[["module WebExtensions\n\nfrom Microsoft.FSharp.Control"]]}""" + "\n" + """{"word":"FSharpFunc","info":[[]]}""" + "\n" + """{"word":"AbstractClassAttribute","info":[["type AbstractClassAttribute =\n  inherit Attribute\n  new : unit -> AbstractClassAttribute"],["new : unit -> AbstractClassAttribute"]]}""" + "\n" + """{"word":"AllowNullLiteralAttribute","info":[["type AllowNullLiteralAttribute =\n  inherit Attribute\n  new : unit -> AllowNullLiteralAttribute\n  new : value:bool -> AllowNullLiteralAttribute\n  member Value : bool"],["new : unit -> AllowNullLiteralAttribute","new : value:bool -> AllowNullLiteralAttribute"]]}""" + "\n" + """{"word":"Async","info":[["type Async =\n  static member AsBeginEnd : computation:('Arg -> Async<'T>) -> ('Arg * AsyncCallback * obj -> IAsyncResult) * (IAsyncResult -> 'T) * (IAsyncResult -> unit)\n  static member AwaitEvent : event:IEvent<'Del,'T> * ?cancelAction:(unit -> unit) -> Async<'T> (requires delegate and 'Del :> Delegate)\n  static member AwaitIAsyncResult : iar:IAsyncResult * ?millisecondsTimeout:int -> Async<bool>\n  static member AwaitTask : task:Task -> Async<unit>\n  static member AwaitTask : task:Task<'T> -> Async<'T>\n  static member AwaitWaitHandle : waitHandle:WaitHandle * ?millisecondsTimeout:int -> Async<bool>\n  static member CancelDefaultToken : unit -> unit\n  static member Catch : computation:Async<'T> -> Async<Choice<'T,exn>>\n  static member Choice : computations:seq<Async<'T option>> -> Async<'T option>\n  static member FromBeginEnd : beginAction:(AsyncCallback * obj -> IAsyncResult) * endAction:(IAsyncResult -> 'T) * ?cancelAction:(unit -> unit) -> Async<'T>\n  ..."],["type Async<'T> ="]]}""" + "\n" + """{"word":"AsyncBuilder","info":[["type AsyncBuilder =\n  private new : unit -> AsyncBuilder\n  member Bind : computation:Async<'T> * binder:('T -> Async<'U>) -> Async<'U>\n  member Combine : computation1:Async<unit> * computation2:Async<'T> -> Async<'T>\n  member Delay : generator:(unit -> Async<'T>) -> Async<'T>\n  member For : sequence:seq<'T> * body:('T -> Async<unit>) -> Async<unit>\n  member Return : value:'T -> Async<'T>\n  member ReturnFrom : computation:Async<'T> -> Async<'T>\n  member TryFinally : computation:Async<'T> * compensation:(unit -> unit) -> Async<'T>\n  member TryWith : computation:Async<'T> * catchHandler:(exn -> Async<'T>) -> Async<'T>\n  member Using : resource:'T * binder:('T -> Async<'U>) -> Async<'U> (requires 'T :> IDisposable)\n  ..."],["private new : unit -> AsyncBuilder"]]}""" + "\n" + """{"word":"AutoOpenAttribute","info":[["type AutoOpenAttribute =\n  inherit Attribute\n  new : unit -> AutoOpenAttribute\n  new : path:string -> AutoOpenAttribute\n  member Path : string"],["new : unit -> AutoOpenAttribute","new : path:string -> AutoOpenAttribute"]]}""" + "\n" + """{"word":"AutoSerializableAttribute","info":[["type AutoSerializableAttribute =\n  inherit Attribute\n  new : value:bool -> AutoSerializableAttribute\n  member Value : bool"],["new : value:bool -> AutoSerializableAttribute"]]}""" + "\n" + """{"word":"CLIEventAttribute","info":[["type CLIEventAttribute =\n  inherit Attribute\n  new : unit -> CLIEventAttribute"],["new : unit -> CLIEventAttribute"]]}""" + "\n" + """{"word":"CLIMutableAttribute","info":[["type CLIMutableAttribute =\n  inherit Attribute\n  new : unit -> CLIMutableAttribute"],["new : unit -> CLIMutableAttribute"]]}""" + "\n" + """{"word":"ClassAttribute","info":[["type ClassAttribute =\n  inherit Attribute\n  new : unit -> ClassAttribute"],["new : unit -> ClassAttribute"]]}""" + "\n" + """{"word":"ComparisonConditionalOnAttribute","info":[["type ComparisonConditionalOnAttribute =\n  inherit Attribute\n  new : unit -> ComparisonConditionalOnAttribute"],["new : unit -> ComparisonConditionalOnAttribute"]]}""" + "\n" + """{"word":"CompilationArgumentCountsAttribute","info":[["type CompilationArgumentCountsAttribute =\n  inherit Attribute\n  new : counts:int [] -> CompilationArgumentCountsAttribute\n  member Counts : IEnumerable<int>"],["new : counts:int [] -> CompilationArgumentCountsAttribute"]]}""" + "\n" + """{"word":"CompilationMappingAttribute","info":[["type CompilationMappingAttribute =\n  inherit Attribute\n  new : sourceConstructFlags:SourceConstructFlags -> CompilationMappingAttribute\n  new : resourceName:string * typeDefinitions:Type [] -> CompilationMappingAttribute\n  new : sourceConstructFlags:SourceConstructFlags * sequenceNumber:int -> CompilationMappingAttribute\n  new : sourceConstructFlags:SourceConstructFlags * variantNumber:int * sequenceNumber:int -> CompilationMappingAttribute\n  member ResourceName : string\n  member SequenceNumber : int\n  member SourceConstructFlags : SourceConstructFlags\n  member TypeDefinitions : Type []\n  member VariantNumber : int"],["new : sourceConstructFlags:SourceConstructFlags -> CompilationMappingAttribute","new : sourceConstructFlags:SourceConstructFlags * sequenceNumber:int -> CompilationMappingAttribute","new : resourceName:string * typeDefinitions:System.Type [] -> CompilationMappingAttribute","new : sourceConstructFlags:SourceConstructFlags * variantNumber:int * sequenceNumber:int -> CompilationMappingAttribute"]]}""" + "\n" + """{"word":"CompilationRepresentationAttribute","info":[["type CompilationRepresentationAttribute =\n  inherit Attribute\n  new : flags:CompilationRepresentationFlags -> CompilationRepresentationAttribute\n  member Flags : CompilationRepresentationFlags"],["new : flags:CompilationRepresentationFlags -> CompilationRepresentationAttribute"]]}""" + "\n" + """{"word":"CompilationRepresentationFlags","info":[["type CompilationRepresentationFlags =\n  | None = 0\n  | Static = 1\n  | Instance = 2\n  | ModuleSuffix = 4\n  | UseNullAsTrueValue = 8\n  | Event = 16"]]}""" + "\n" + """{"word":"CompilationSourceNameAttribute","info":[["type CompilationSourceNameAttribute =\n  inherit Attribute\n  new : sourceName:string -> CompilationSourceNameAttribute\n  member SourceName : string"],["new : sourceName:string -> CompilationSourceNameAttribute"]]}""" + "\n" + """{"word":"CompiledNameAttribute","info":[["type CompiledNameAttribute =\n  inherit Attribute\n  new : compiledName:string -> CompiledNameAttribute\n  member CompiledName : string"],["new : compiledName:string -> CompiledNameAttribute"]]}""" + "\n" + """{"word":"CompilerMessageAttribute","info":[["type CompilerMessageAttribute =\n  inherit Attribute\n  new : message:string * messageNumber:int -> CompilerMessageAttribute\n  member IsError : bool\n  member IsHidden : bool\n  member Message : string\n  member MessageNumber : int\n  member IsError : bool with set\n  member IsHidden : bool with set"],["new : message:string * messageNumber:int -> CompilerMessageAttribute"]]}""" + "\n" + """{"word":"CustomComparisonAttribute","info":[["type CustomComparisonAttribute =\n  inherit Attribute\n  new : unit -> CustomComparisonAttribute"],["new : unit -> CustomComparisonAttribute"]]}""" + "\n" + """{"word":"CustomEqualityAttribute","info":[["type CustomEqualityAttribute =\n  inherit Attribute\n  new : unit -> CustomEqualityAttribute"],["new : unit -> CustomEqualityAttribute"]]}""" + "\n" + """{"word":"CustomOperationAttribute","info":[["type CustomOperationAttribute =\n  inherit Attribute\n  new : name:string -> CustomOperationAttribute\n  member AllowIntoPattern : bool\n  member IsLikeGroupJoin : bool\n  member IsLikeJoin : bool\n  member IsLikeZip : bool\n  member JoinConditionWord : string\n  member MaintainsVariableSpace : bool\n  member MaintainsVariableSpaceUsingBind : bool\n  member Name : string\n  ..."],["new : name:string -> CustomOperationAttribute"]]}""" + "\n" + """{"word":"DefaultAugmentationAttribute","info":[["type DefaultAugmentationAttribute =\n  inherit Attribute\n  new : value:bool -> DefaultAugmentationAttribute\n  member Value : bool"],["new : value:bool -> DefaultAugmentationAttribute"]]}""" + "\n" + """{"word":"DefaultValueAttribute","info":[["type DefaultValueAttribute =\n  inherit Attribute\n  new : unit -> DefaultValueAttribute\n  new : check:bool -> DefaultValueAttribute\n  member Check : bool"],["new : unit -> DefaultValueAttribute","new : check:bool -> DefaultValueAttribute"]]}""" + "\n" + """{"word":"EntryPointAttribute","info":[["type EntryPointAttribute =\n  inherit Attribute\n  new : unit -> EntryPointAttribute"],["new : unit -> EntryPointAttribute"]]}""" + "\n" + """{"word":"EqualityConditionalOnAttribute","info":[["type EqualityConditionalOnAttribute =\n  inherit Attribute\n  new : unit -> EqualityConditionalOnAttribute"],["new : unit -> EqualityConditionalOnAttribute"]]}""" + "\n" + """{"word":"ExperimentalAttribute","info":[["type ExperimentalAttribute =\n  inherit Attribute\n  new : message:string -> ExperimentalAttribute\n  member Message : string"],["new : message:string -> ExperimentalAttribute"]]}""" + "\n" + """{"word":"FSharpInterfaceDataVersionAttribute","info":[["type FSharpInterfaceDataVersionAttribute =\n  inherit Attribute\n  new : major:int * minor:int * release:int -> FSharpInterfaceDataVersionAttribute\n  member Major : int\n  member Minor : int\n  member Release : int"],["new : major:int * minor:int * release:int -> FSharpInterfaceDataVersionAttribute"]]}""" + "\n" + """{"word":"FuncConvert","info":[["type FuncConvert =\n  static member FuncFromTupled : func:('T1 * 'T2 * 'T3 * 'T4 * 'T5 -> 'U) -> ('T1 -> 'T2 -> 'T3 -> 'T4 -> 'T5 -> 'U)\n  static member FuncFromTupled : func:('T1 * 'T2 * 'T3 * 'T4 -> 'U) -> ('T1 -> 'T2 -> 'T3 -> 'T4 -> 'U)\n  static member FuncFromTupled : func:('T1 * 'T2 * 'T3 -> 'U) -> ('T1 -> 'T2 -> 'T3 -> 'U)\n  static member FuncFromTupled : func:('T1 * 'T2 -> 'U) -> ('T1 -> 'T2 -> 'U)\n  static member ToFSharpFunc : converter:Converter<'T,'U> -> ('T -> 'U)\n  static member ToFSharpFunc : action:Action<'T> -> ('T -> unit)"]]}""" + "\n" + """{"word":"GeneralizableValueAttribute","info":[["type GeneralizableValueAttribute =\n  inherit Attribute\n  new : unit -> GeneralizableValueAttribute"],["new : unit -> GeneralizableValueAttribute"]]}""" + "\n" + """{"word":"InterfaceAttribute","info":[["type InterfaceAttribute =\n  inherit Attribute\n  new : unit -> InterfaceAttribute"],["new : unit -> InterfaceAttribute"]]}""" + "\n" + """{"word":"LiteralAttribute","info":[["type LiteralAttribute =\n  inherit Attribute\n  new : unit -> LiteralAttribute"],["new : unit -> LiteralAttribute"]]}""" + "\n" + """{"word":"MeasureAnnotatedAbbreviationAttribute","info":[["type MeasureAnnotatedAbbreviationAttribute =\n  inherit Attribute\n  new : unit -> MeasureAnnotatedAbbreviationAttribute"],["new : unit -> MeasureAnnotatedAbbreviationAttribute"]]}""" + "\n" + """{"word":"MeasureAttribute","info":[["type MeasureAttribute =\n  inherit Attribute\n  new : unit -> MeasureAttribute"],["new : unit -> MeasureAttribute"]]}""" + "\n" + """{"word":"NoComparisonAttribute","info":[["type NoComparisonAttribute =\n  inherit Attribute\n  new : unit -> NoComparisonAttribute"],["new : unit -> NoComparisonAttribute"]]}""" + "\n" + """{"word":"NoDynamicInvocationAttribute","info":[["type NoDynamicInvocationAttribute =\n  inherit Attribute\n  new : unit -> NoDynamicInvocationAttribute"],["new : unit -> NoDynamicInvocationAttribute"]]}""" + "\n" + """{"word":"NoEqualityAttribute","info":[["type NoEqualityAttribute =\n  inherit Attribute\n  new : unit -> NoEqualityAttribute"],["new : unit -> NoEqualityAttribute"]]}""" + "\n" + """{"word":"OptionalArgumentAttribute","info":[["type OptionalArgumentAttribute =\n  inherit Attribute\n  new : unit -> OptionalArgumentAttribute"],["new : unit -> OptionalArgumentAttribute"]]}""" + "\n" + """{"word":"ProjectionParameterAttribute","info":[["type ProjectionParameterAttribute =\n  inherit Attribute\n  new : unit -> ProjectionParameterAttribute"],["new : unit -> ProjectionParameterAttribute"]]}""" + "\n" + """{"word":"ReferenceEqualityAttribute","info":[["type ReferenceEqualityAttribute =\n  inherit Attribute\n  new : unit -> ReferenceEqualityAttribute"],["new : unit -> ReferenceEqualityAttribute"]]}""" + "\n" + """{"word":"ReflectedDefinitionAttribute","info":[["type ReflectedDefinitionAttribute =\n  inherit Attribute\n  new : unit -> ReflectedDefinitionAttribute\n  new : includeValue:bool -> ReflectedDefinitionAttribute\n  member IncludeValue : bool"],["new : unit -> ReflectedDefinitionAttribute","new : includeValue:bool -> ReflectedDefinitionAttribute"]]}""" + "\n" + """{"word":"RequireQualifiedAccessAttribute","info":[["type RequireQualifiedAccessAttribute =\n  inherit Attribute\n  new : unit -> RequireQualifiedAccessAttribute"],["new : unit -> RequireQualifiedAccessAttribute"]]}""" + "\n" + """{"word":"RequiresExplicitTypeArgumentsAttribute","info":[["type RequiresExplicitTypeArgumentsAttribute =\n  inherit Attribute\n  new : unit -> RequiresExplicitTypeArgumentsAttribute"],["new : unit -> RequiresExplicitTypeArgumentsAttribute"]]}""" + "\n" + """{"word":"SealedAttribute","info":[["type SealedAttribute =\n  inherit Attribute\n  new : unit -> SealedAttribute\n  new : value:bool -> SealedAttribute\n  member Value : bool"],["new : unit -> SealedAttribute","new : value:bool -> SealedAttribute"]]}""" + "\n" + """{"word":"SourceConstructFlags","info":[["type SourceConstructFlags =\n  | None = 0\n  | SumType = 1\n  | RecordType = 2\n  | ObjectType = 3\n  | Field = 4\n  | Exception = 5\n  | Closure = 6\n  | Module = 7\n  | UnionCase = 8\n  | Value = 9\n  | KindMask = 31\n  | NonPublicRepresentation = 32"]]}""" + "\n" + """{"word":"StructAttribute","info":[["type StructAttribute =\n  inherit Attribute\n  new : unit -> StructAttribute"],["new : unit -> StructAttribute"]]}""" + "\n" + """{"word":"StructuralComparisonAttribute","info":[["type StructuralComparisonAttribute =\n  inherit Attribute\n  new : unit -> StructuralComparisonAttribute"],["new : unit -> StructuralComparisonAttribute"]]}""" + "\n" + """{"word":"StructuralEqualityAttribute","info":[["type StructuralEqualityAttribute =\n  inherit Attribute\n  new : unit -> StructuralEqualityAttribute"],["new : unit -> StructuralEqualityAttribute"]]}""" + "\n" + """{"word":"StructuredFormatDisplayAttribute","info":[["type StructuredFormatDisplayAttribute =\n  inherit Attribute\n  new : value:string -> StructuredFormatDisplayAttribute\n  member Value : string"],["new : value:string -> StructuredFormatDisplayAttribute"]]}""" + "\n" + """{"word":"UnverifiableAttribute","info":[["type UnverifiableAttribute =\n  inherit Attribute\n  new : unit -> UnverifiableAttribute"],["new : unit -> UnverifiableAttribute"]]}""" + "\n" + """{"word":"VolatileFieldAttribute","info":[["type VolatileFieldAttribute =\n  inherit Attribute\n  new : unit -> VolatileFieldAttribute"],["new : unit -> VolatileFieldAttribute"]]}""" + "\n" + """{"word":"bigint","info":[["type bigint = System.Numerics.BigInteger"]]}""" + "\n" + """{"word":"bool","info":[["type bool = System.Boolean"]]}""" + "\n" + """{"word":"exn","info":[["type exn = System.Exception"]]}""" + "\n" + """{"word":"obj","info":[["type obj = System.Object"]]}""" + "\n" + """{"word":"unit","info":[["type unit = Unit"]]}""" + "\n" + """{"word":"AsyncReplyChannel","info":[["type AsyncReplyChannel<'Reply> =\n  member Reply : value:'Reply -> unit"]]}""" + "\n" + """{"word":"DelegateEvent","info":[["type DelegateEvent<'Delegate (requires 'Delegate :> Delegate)> =\n  new : unit -> DelegateEvent<'Delegate>\n  member Trigger : args:obj [] -> unit\n  member Publish : IDelegateEvent<'Delegate>"],["new : unit -> DelegateEvent<'Delegate>"]]}""" + "\n" + """{"word":"Handler","info":[["type Handler<'T> =\n  delegate of obj * 'T -> unit"]]}""" + "\n" + """{"word":"IDelegateEvent","info":[["type IDelegateEvent<'Delegate (requires 'Delegate :> Delegate)> =\n  interface\n    abstract member AddHandler : handler:'Delegate -> unit\n    abstract member RemoveHandler : handler:'Delegate -> unit\n  end"]]}""" + "\n" + """{"word":"IEvent","info":[["type IEvent<'T> = IEvent<Handler<'T>,'T>"]]}""" + "\n" + """{"word":"MailboxProcessor","info":[["type MailboxProcessor<'Msg> =\n  interface IDisposable\n  new : body:(MailboxProcessor<'Msg> -> Async<unit>) * ?cancellationToken:CancellationToken -> MailboxProcessor<'Msg>\n  member Post : message:'Msg -> unit\n  member PostAndAsyncReply : buildMessage:(AsyncReplyChannel<'Reply> -> 'Msg) * ?timeout:int -> Async<'Reply>\n  member PostAndReply : buildMessage:(AsyncReplyChannel<'Reply> -> 'Msg) * ?timeout:int -> 'Reply\n  member PostAndTryAsyncReply : buildMessage:(AsyncReplyChannel<'Reply> -> 'Msg) * ?timeout:int -> Async<'Reply option>\n  member Receive : ?timeout:int -> Async<'Msg>\n  member Scan : scanner:('Msg -> Async<'T> option) * ?timeout:int -> Async<'T>\n  member Start : unit -> unit\n  member TryPostAndReply : buildMessage:(AsyncReplyChannel<'Reply> -> 'Msg) * ?timeout:int -> 'Reply option\n  ..."],["new : body:(MailboxProcessor<'Msg> -> Async<unit>) * ?cancellationToken:System.Threading.CancellationToken -> MailboxProcessor<'Msg>"]]}""" + "\n" + """{"word":"ResizeArray","info":[["type ResizeArray<'T> = System.Collections.Generic.List<'T>"]]}""" + "\n" + """{"word":"array","info":[["type 'T array = 'T []"]]}""" + "\n" + """{"word":"byref","info":[["type byref<'T> = (# \"<Common IL Type Omitted>\" #)"]]}""" + "\n" + """{"word":"ilsigptr","info":[["type ilsigptr<'T> = (# \"<Common IL Type Omitted>\" #)"]]}""" + "\n" + """{"word":"list","info":[["type 'T list = List<'T>"]]}""" + "\n" + """{"word":"nativeptr","info":[["type nativeptr<'T (requires unmanaged)> = (# \"<Common IL Type Omitted>\" #)"]]}""" + "\n" + """{"word":"option","info":[["type 'T option = Option<'T>"]]}""" + "\n" + """{"word":"Choice","info":[["type Choice<'T1,'T2> =\n  | Choice1Of2 of 'T1\n  | Choice2Of2 of 'T2"],["type Choice<'T1,'T2,'T3> =\n  | Choice1Of3 of 'T1\n  | Choice2Of3 of 'T2\n  | Choice3Of3 of 'T3"],["type Choice<'T1,'T2,'T3,'T4> =\n  | Choice1Of4 of 'T1\n  | Choice2Of4 of 'T2\n  | Choice3Of4 of 'T3\n  | Choice4Of4 of 'T4"],["type Choice<'T1,'T2,'T3,'T4,'T5> =\n  | Choice1Of5 of 'T1\n  | Choice2Of5 of 'T2\n  | Choice3Of5 of 'T3\n  | Choice4Of5 of 'T4\n  | Choice5Of5 of 'T5"],["type Choice<'T1,'T2,'T3,'T4,'T5,'T6> =\n  | Choice1Of6 of 'T1\n  | Choice2Of6 of 'T2\n  | Choice3Of6 of 'T3\n  | Choice4Of6 of 'T4\n  | Choice5Of6 of 'T5\n  | Choice6Of6 of 'T6"],["type Choice<'T1,'T2,'T3,'T4,'T5,'T6,'T7> =\n  | Choice1Of7 of 'T1\n  | Choice2Of7 of 'T2\n  | Choice3Of7 of 'T3\n  | Choice4Of7 of 'T4\n  | Choice5Of7 of 'T5\n  | Choice6Of7 of 'T6\n  | Choice7Of7 of 'T7"]]}""" + "\n" + """{"word":"Format","info":[["type Format<'Printer,'State,'Residue,'Result> = PrintfFormat<'Printer,'State,'Residue,'Result>"],["type Format<'Printer,'State,'Residue,'Result,'Tuple> = PrintfFormat<'Printer,'State,'Residue,'Result,'Tuple>"]]}""" + "\n" + """{"word":"PrintfFormat","info":[["type PrintfFormat<'Printer,'State,'Residue,'Result> =\n  new : value:string -> PrintfFormat<'Printer,'State,'Residue,'Result>\n  member Value : string"],["type PrintfFormat<'Printer,'State,'Residue,'Result,'Tuple> =\n  inherit PrintfFormat<'Printer,'State,'Residue,'Result>\n  new : value:string -> PrintfFormat<'Printer,'State,'Residue,'Result,'Tuple>"],["new : value:string -> PrintfFormat<'Printer,'State,'Residue,'Result>"],["new : value:string -> PrintfFormat<'Printer,'State,'Residue,'Result,'Tuple>"]]}""" + "\n" + """{"word":"FSharpTypeFunc","info":[["new : unit -> FSharpTypeFunc"]]}"""
            "Array","""{"word":"allPairs","info":[["val allPairs : array1:'T1 [] -> array2:'T2 [] -> ('T1 * 'T2) []"]]}""" + "\n" + """{"word":"append","info":[["val append : array1:'T [] -> array2:'T [] -> 'T []"]]}""" + "\n" + """{"word":"average","info":[["val average : array:'T [] -> 'T (requires member ( + ) and member DivideByInt and member get_Zero)"]]}""" + "\n" + """{"word":"averageBy","info":[["val averageBy : projection:('T -> 'U) -> array:'T [] -> 'U (requires member ( + ) and member DivideByInt and member get_Zero)"]]}""" + "\n" + """{"word":"blit","info":[["val blit : source:'T [] -> sourceIndex:int -> target:'T [] -> targetIndex:int -> count:int -> unit"]]}""" + "\n" + """{"word":"collect","info":[["val collect : mapping:('T -> 'U []) -> array:'T [] -> 'U []"]]}""" + "\n" + """{"word":"compareWith","info":[["val compareWith : comparer:('T -> 'T -> int) -> array1:'T [] -> array2:'T [] -> int"]]}""" + "\n" + """{"word":"concat","info":[["val concat : arrays:seq<'T []> -> 'T []"]]}""" + "\n" + """{"word":"contains","info":[["val contains : value:'T -> array:'T [] -> bool (requires equality)"]]}""" + "\n" + """{"word":"copy","info":[["val copy : array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"countBy","info":[["val countBy : projection:('T -> 'Key) -> array:'T [] -> ('Key * int) [] (requires equality)"]]}""" + "\n" + """{"word":"create","info":[["val create : count:int -> value:'T -> 'T []"]]}""" + "\n" + """{"word":"tryHead","info":[["val tryHead : array:'T [] -> 'T option"]]}""" + "\n" + """{"word":"tryPick","info":[["val tryPick : chooser:('T -> 'U option) -> array:'T [] -> 'U option"]]}""" + "\n" + """{"word":"fill","info":[["val fill : target:'T [] -> targetIndex:int -> count:int -> value:'T -> unit"]]}""" + "\n" + """{"word":"pick","info":[["val pick : chooser:('T -> 'U option) -> array:'T [] -> 'U"]]}""" + "\n" + """{"word":"choose","info":[["val choose : chooser:('T -> 'U option) -> array:'T [] -> 'U []"]]}""" + "\n" + """{"word":"chunkBySize","info":[["val chunkBySize : chunkSize:int -> array:'T [] -> 'T [] []"]]}""" + "\n" + """{"word":"distinct","info":[["val distinct : array:'T [] -> 'T [] (requires equality)"]]}""" + "\n" + """{"word":"distinctBy","info":[["val distinctBy : projection:('T -> 'Key) -> array:'T [] -> 'T [] (requires equality)"]]}""" + "\n" + """{"word":"splitInto","info":[["val splitInto : count:int -> array:'T [] -> 'T [] []"]]}""" + "\n" + """{"word":"empty","info":[["val empty<'T> : 'T []"]]}""" + "\n" + """{"word":"exactlyOne","info":[["val exactlyOne : array:'T [] -> 'T"]]}""" + "\n" + """{"word":"except","info":[["val except : itemsToExclude:seq<'T> -> array:'T [] -> 'T [] (requires equality)"]]}""" + "\n" + """{"word":"exists","info":[["val exists : predicate:('T -> bool) -> array:'T [] -> bool"]]}""" + "\n" + """{"word":"exists2","info":[["val exists2 : predicate:('T1 -> 'T2 -> bool) -> array1:'T1 [] -> array2:'T2 [] -> bool"]]}""" + "\n" + """{"word":"filter","info":[["val filter : predicate:('T -> bool) -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"find","info":[["val find : predicate:('T -> bool) -> array:'T [] -> 'T"]]}""" + "\n" + """{"word":"findBack","info":[["val findBack : predicate:('T -> bool) -> array:'T [] -> 'T"]]}""" + "\n" + """{"word":"findIndex","info":[["val findIndex : predicate:('T -> bool) -> array:'T [] -> int"]]}""" + "\n" + """{"word":"findIndexBack","info":[["val findIndexBack : predicate:('T -> bool) -> array:'T [] -> int"]]}""" + "\n" + """{"word":"forall","info":[["val forall : predicate:('T -> bool) -> array:'T [] -> bool"]]}""" + "\n" + """{"word":"forall2","info":[["val forall2 : predicate:('T1 -> 'T2 -> bool) -> array1:'T1 [] -> array2:'T2 [] -> bool"]]}""" + "\n" + """{"word":"fold","info":[["val fold : folder:('State -> 'T -> 'State) -> state:'State -> array:'T [] -> 'State"]]}""" + "\n" + """{"word":"foldBack","info":[["val foldBack : folder:('T -> 'State -> 'State) -> array:'T [] -> state:'State -> 'State"]]}""" + "\n" + """{"word":"fold2","info":[["val fold2 : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> array1:'T1 [] -> array2:'T2 [] -> 'State"]]}""" + "\n" + """{"word":"foldBack2","info":[["val foldBack2 : folder:('T1 -> 'T2 -> 'State -> 'State) -> array1:'T1 [] -> array2:'T2 [] -> state:'State -> 'State"]]}""" + "\n" + """{"word":"get","info":[["val get : array:'T [] -> index:int -> 'T"]]}""" + "\n" + """{"word":"head","info":[["val head : array:'T [] -> 'T"]]}""" + "\n" + """{"word":"groupBy","info":[["val groupBy : projection:('T -> 'Key) -> array:'T [] -> ('Key * 'T []) [] (requires equality)"]]}""" + "\n" + """{"word":"indexed","info":[["val indexed : array:'T [] -> (int * 'T) []"]]}""" + "\n" + """{"word":"init","info":[["val init : count:int -> initializer:(int -> 'T) -> 'T []"]]}""" + "\n" + """{"word":"zeroCreate","info":[["val zeroCreate : count:int -> 'T []"]]}""" + "\n" + """{"word":"isEmpty","info":[["val isEmpty : array:'T [] -> bool"]]}""" + "\n" + """{"word":"iter","info":[["val iter : action:('T -> unit) -> array:'T [] -> unit"]]}""" + "\n" + """{"word":"iter2","info":[["val iter2 : action:('T1 -> 'T2 -> unit) -> array1:'T1 [] -> array2:'T2 [] -> unit"]]}""" + "\n" + """{"word":"iteri","info":[["val iteri : action:(int -> 'T -> unit) -> array:'T [] -> unit"]]}""" + "\n" + """{"word":"iteri2","info":[["val iteri2 : action:(int -> 'T1 -> 'T2 -> unit) -> array1:'T1 [] -> array2:'T2 [] -> unit"]]}""" + "\n" + """{"word":"last","info":[["val last : array:'T [] -> 'T"]]}""" + "\n" + """{"word":"item","info":[["val item : index:int -> array:'T [] -> 'T"]]}""" + "\n" + """{"word":"length","info":[["val length : array:'T [] -> int"]]}""" + "\n" + """{"word":"tryLast","info":[["val tryLast : array:'T [] -> 'T option"]]}""" + "\n" + """{"word":"map","info":[["val map : mapping:('T -> 'U) -> array:'T [] -> 'U []"]]}""" + "\n" + """{"word":"map2","info":[["val map2 : mapping:('T1 -> 'T2 -> 'U) -> array1:'T1 [] -> array2:'T2 [] -> 'U []"]]}""" + "\n" + """{"word":"mapFold","info":[["val mapFold : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> array:'T [] -> 'Result [] * 'State"]]}""" + "\n" + """{"word":"mapFoldBack","info":[["val mapFoldBack : mapping:('T -> 'State -> 'Result * 'State) -> array:'T [] -> state:'State -> 'Result [] * 'State"]]}""" + "\n" + """{"word":"map3","info":[["val map3 : mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> array1:'T1 [] -> array2:'T2 [] -> array3:'T3 [] -> 'U []"]]}""" + "\n" + """{"word":"mapi2","info":[["val mapi2 : mapping:(int -> 'T1 -> 'T2 -> 'U) -> array1:'T1 [] -> array2:'T2 [] -> 'U []"]]}""" + "\n" + """{"word":"mapi","info":[["val mapi : mapping:(int -> 'T -> 'U) -> array:'T [] -> 'U []"]]}""" + "\n" + """{"word":"max","info":[["val max : array:'T [] -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"maxBy","info":[["val maxBy : projection:('T -> 'U) -> array:'T [] -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"min","info":[["val min : array:'T [] -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"minBy","info":[["val minBy : projection:('T -> 'U) -> array:'T [] -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"ofList","info":[["val ofList : list:'T list -> 'T []"]]}""" + "\n" + """{"word":"ofSeq","info":[["val ofSeq : source:seq<'T> -> 'T []"]]}""" + "\n" + """{"word":"pairwise","info":[["val pairwise : array:'T [] -> ('T * 'T) []"]]}""" + "\n" + """{"word":"partition","info":[["val partition : predicate:('T -> bool) -> array:'T [] -> 'T [] * 'T []"]]}""" + "\n" + """{"word":"permute","info":[["val permute : indexMap:(int -> int) -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"reduce","info":[["val reduce : reduction:('T -> 'T -> 'T) -> array:'T [] -> 'T"]]}""" + "\n" + """{"word":"reduceBack","info":[["val reduceBack : reduction:('T -> 'T -> 'T) -> array:'T [] -> 'T"]]}""" + "\n" + """{"word":"replicate","info":[["val replicate : count:int -> initial:'T -> 'T []"]]}""" + "\n" + """{"word":"rev","info":[["val rev : array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"scan","info":[["val scan : folder:('State -> 'T -> 'State) -> state:'State -> array:'T [] -> 'State []"]]}""" + "\n" + """{"word":"scanBack","info":[["val scanBack : folder:('T -> 'State -> 'State) -> array:'T [] -> state:'State -> 'State []"]]}""" + "\n" + """{"word":"singleton","info":[["val singleton : value:'T -> 'T []"]]}""" + "\n" + """{"word":"set","info":[["val set : array:'T [] -> index:int -> value:'T -> unit"]]}""" + "\n" + """{"word":"skip","info":[["val skip : count:int -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"skipWhile","info":[["val skipWhile : predicate:('T -> bool) -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"sub","info":[["val sub : array:'T [] -> startIndex:int -> count:int -> 'T []"]]}""" + "\n" + """{"word":"sort","info":[["val sort : array:'T [] -> 'T [] (requires comparison)"]]}""" + "\n" + """{"word":"sortBy","info":[["val sortBy : projection:('T -> 'Key) -> array:'T [] -> 'T [] (requires comparison)"]]}""" + "\n" + """{"word":"sortWith","info":[["val sortWith : comparer:('T -> 'T -> int) -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"sortInPlaceBy","info":[["val sortInPlaceBy : projection:('T -> 'Key) -> array:'T [] -> unit (requires comparison)"]]}""" + "\n" + """{"word":"sortInPlaceWith","info":[["val sortInPlaceWith : comparer:('T -> 'T -> int) -> array:'T [] -> unit"]]}""" + "\n" + """{"word":"sortInPlace","info":[["val sortInPlace : array:'T [] -> unit (requires comparison)"]]}""" + "\n" + """{"word":"splitAt","info":[["val splitAt : index:int -> array:'T [] -> 'T [] * 'T []"]]}""" + "\n" + """{"word":"sortDescending","info":[["val sortDescending : array:'T [] -> 'T [] (requires comparison)"]]}""" + "\n" + """{"word":"sortByDescending","info":[["val sortByDescending : projection:('T -> 'Key) -> array:'T [] -> 'T [] (requires comparison)"]]}""" + "\n" + """{"word":"sum","info":[["val sum : array:'T [] -> 'T (requires member ( + ) and member get_Zero)"]]}""" + "\n" + """{"word":"sumBy","info":[["val sumBy : projection:('T -> 'U) -> array:'T [] -> 'U (requires member ( + ) and member get_Zero)"]]}""" + "\n" + """{"word":"take","info":[["val take : count:int -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"takeWhile","info":[["val takeWhile : predicate:('T -> bool) -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"tail","info":[["val tail : array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"toList","info":[["val toList : array:'T [] -> 'T list"]]}""" + "\n" + """{"word":"toSeq","info":[["val toSeq : array:'T [] -> seq<'T>"]]}""" + "\n" + """{"word":"truncate","info":[["val truncate : count:int -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"tryFind","info":[["val tryFind : predicate:('T -> bool) -> array:'T [] -> 'T option"]]}""" + "\n" + """{"word":"tryFindBack","info":[["val tryFindBack : predicate:('T -> bool) -> array:'T [] -> 'T option"]]}""" + "\n" + """{"word":"tryFindIndex","info":[["val tryFindIndex : predicate:('T -> bool) -> array:'T [] -> int option"]]}""" + "\n" + """{"word":"tryItem","info":[["val tryItem : index:int -> array:'T [] -> 'T option"]]}""" + "\n" + """{"word":"tryFindIndexBack","info":[["val tryFindIndexBack : predicate:('T -> bool) -> array:'T [] -> int option"]]}""" + "\n" + """{"word":"unfold","info":[["val unfold : generator:('State -> ('T * 'State) option) -> state:'State -> 'T []"]]}""" + "\n" + """{"word":"unzip","info":[["val unzip : array:('T1 * 'T2) [] -> 'T1 [] * 'T2 []"]]}""" + "\n" + """{"word":"unzip3","info":[["val unzip3 : array:('T1 * 'T2 * 'T3) [] -> 'T1 [] * 'T2 [] * 'T3 []"]]}""" + "\n" + """{"word":"where","info":[["val where : predicate:('T -> bool) -> array:'T [] -> 'T []"]]}""" + "\n" + """{"word":"windowed","info":[["val windowed : windowSize:int -> array:'T [] -> 'T [] []"]]}""" + "\n" + """{"word":"zip","info":[["val zip : array1:'T1 [] -> array2:'T2 [] -> ('T1 * 'T2) []"]]}""" + "\n" + """{"word":"zip3","info":[["val zip3 : array1:'T1 [] -> array2:'T2 [] -> array3:'T3 [] -> ('T1 * 'T2 * 'T3) []"]]}""" + "\n" + """{"word":"Parallel","info":[["module Parallel\n\nfrom Microsoft.FSharp.Collections.ArrayModule"]]}"""
            "List","""{"word":"allPairs","info":[["val allPairs : list1:'T1 list -> list2:'T2 list -> ('T1 * 'T2) list"]]}""" + "\n" + """{"word":"append","info":[["val append : list1:'T list -> list2:'T list -> 'T list"]]}""" + "\n" + """{"word":"average","info":[["val average : list:'T list -> 'T (requires member ( + ) and member DivideByInt and member get_Zero)"]]}""" + "\n" + """{"word":"averageBy","info":[["val averageBy : projection:('T -> 'U) -> list:'T list -> 'U (requires member ( + ) and member DivideByInt and member get_Zero)"]]}""" + "\n" + """{"word":"choose","info":[["val choose : chooser:('T -> 'U option) -> list:'T list -> 'U list"]]}""" + "\n" + """{"word":"chunkBySize","info":[["val chunkBySize : chunkSize:int -> list:'T list -> 'T list list"]]}""" + "\n" + """{"word":"collect","info":[["val collect : mapping:('T -> 'U list) -> list:'T list -> 'U list"]]}""" + "\n" + """{"word":"compareWith","info":[["val compareWith : comparer:('T -> 'T -> int) -> list1:'T list -> list2:'T list -> int"]]}""" + "\n" + """{"word":"concat","info":[["val concat : lists:seq<'T list> -> 'T list"]]}""" + "\n" + """{"word":"contains","info":[["val contains : value:'T -> source:'T list -> bool (requires equality)"]]}""" + "\n" + """{"word":"distinct","info":[["val distinct : list:'T list -> 'T list (requires equality)"]]}""" + "\n" + """{"word":"distinctBy","info":[["val distinctBy : projection:('T -> 'Key) -> list:'T list -> 'T list (requires equality)"]]}""" + "\n" + """{"word":"countBy","info":[["val countBy : projection:('T -> 'Key) -> list:'T list -> ('Key * int) list (requires equality)"]]}""" + "\n" + """{"word":"splitInto","info":[["val splitInto : count:int -> list:'T list -> 'T list list"]]}""" + "\n" + """{"word":"empty","info":[["val empty<'T> : 'T list"]]}""" + "\n" + """{"word":"except","info":[["val except : itemsToExclude:seq<'T> -> list:'T list -> 'T list (requires equality)"]]}""" + "\n" + """{"word":"exactlyOne","info":[["val exactlyOne : list:'T list -> 'T"]]}""" + "\n" + """{"word":"exists","info":[["val exists : predicate:('T -> bool) -> list:'T list -> bool"]]}""" + "\n" + """{"word":"exists2","info":[["val exists2 : predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool"]]}""" + "\n" + """{"word":"find","info":[["val find : predicate:('T -> bool) -> list:'T list -> 'T"]]}""" + "\n" + """{"word":"findBack","info":[["val findBack : predicate:('T -> bool) -> list:'T list -> 'T"]]}""" + "\n" + """{"word":"findIndex","info":[["val findIndex : predicate:('T -> bool) -> list:'T list -> int"]]}""" + "\n" + """{"word":"findIndexBack","info":[["val findIndexBack : predicate:('T -> bool) -> list:'T list -> int"]]}""" + "\n" + """{"word":"filter","info":[["val filter : predicate:('T -> bool) -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"fold","info":[["val fold : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State"]]}""" + "\n" + """{"word":"fold2","info":[["val fold2 : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> list1:'T1 list -> list2:'T2 list -> 'State"]]}""" + "\n" + """{"word":"foldBack","info":[["val foldBack : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State"]]}""" + "\n" + """{"word":"foldBack2","info":[["val foldBack2 : folder:('T1 -> 'T2 -> 'State -> 'State) -> list1:'T1 list -> list2:'T2 list -> state:'State -> 'State"]]}""" + "\n" + """{"word":"forall","info":[["val forall : predicate:('T -> bool) -> list:'T list -> bool"]]}""" + "\n" + """{"word":"forall2","info":[["val forall2 : predicate:('T1 -> 'T2 -> bool) -> list1:'T1 list -> list2:'T2 list -> bool"]]}""" + "\n" + """{"word":"groupBy","info":[["val groupBy : projection:('T -> 'Key) -> list:'T list -> ('Key * 'T list) list (requires equality)"]]}""" + "\n" + """{"word":"head","info":[["val head : list:'T list -> 'T"]]}""" + "\n" + """{"word":"indexed","info":[["val indexed : list:'T list -> (int * 'T) list"]]}""" + "\n" + """{"word":"init","info":[["val init : length:int -> initializer:(int -> 'T) -> 'T list"]]}""" + "\n" + """{"word":"isEmpty","info":[["val isEmpty : list:'T list -> bool"]]}""" + "\n" + """{"word":"item","info":[["val item : index:int -> list:'T list -> 'T"]]}""" + "\n" + """{"word":"iter","info":[["val iter : action:('T -> unit) -> list:'T list -> unit"]]}""" + "\n" + """{"word":"iter2","info":[["val iter2 : action:('T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit"]]}""" + "\n" + """{"word":"iteri","info":[["val iteri : action:(int -> 'T -> unit) -> list:'T list -> unit"]]}""" + "\n" + """{"word":"iteri2","info":[["val iteri2 : action:(int -> 'T1 -> 'T2 -> unit) -> list1:'T1 list -> list2:'T2 list -> unit"]]}""" + "\n" + """{"word":"last","info":[["val last : list:'T list -> 'T"]]}""" + "\n" + """{"word":"length","info":[["val length : list:'T list -> int"]]}""" + "\n" + """{"word":"tryLast","info":[["val tryLast : list:'T list -> 'T option"]]}""" + "\n" + """{"word":"map","info":[["val map : mapping:('T -> 'U) -> list:'T list -> 'U list"]]}""" + "\n" + """{"word":"map2","info":[["val map2 : mapping:('T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list"]]}""" + "\n" + """{"word":"map3","info":[["val map3 : mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> 'U list"]]}""" + "\n" + """{"word":"mapFold","info":[["val mapFold : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> list:'T list -> 'Result list * 'State"]]}""" + "\n" + """{"word":"mapFoldBack","info":[["val mapFoldBack : mapping:('T -> 'State -> 'Result * 'State) -> list:'T list -> state:'State -> 'Result list * 'State"]]}""" + "\n" + """{"word":"mapi","info":[["val mapi : mapping:(int -> 'T -> 'U) -> list:'T list -> 'U list"]]}""" + "\n" + """{"word":"mapi2","info":[["val mapi2 : mapping:(int -> 'T1 -> 'T2 -> 'U) -> list1:'T1 list -> list2:'T2 list -> 'U list"]]}""" + "\n" + """{"word":"max","info":[["val max : list:'T list -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"maxBy","info":[["val maxBy : projection:('T -> 'U) -> list:'T list -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"min","info":[["val min : list:'T list -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"minBy","info":[["val minBy : projection:('T -> 'U) -> list:'T list -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"ofArray","info":[["val ofArray : array:'T [] -> 'T list"]]}""" + "\n" + """{"word":"ofSeq","info":[["val ofSeq : source:seq<'T> -> 'T list"]]}""" + "\n" + """{"word":"pairwise","info":[["val pairwise : list:'T list -> ('T * 'T) list"]]}""" + "\n" + """{"word":"partition","info":[["val partition : predicate:('T -> bool) -> list:'T list -> 'T list * 'T list"]]}""" + "\n" + """{"word":"pick","info":[["val pick : chooser:('T -> 'U option) -> list:'T list -> 'U"]]}""" + "\n" + """{"word":"permute","info":[["val permute : indexMap:(int -> int) -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"reduce","info":[["val reduce : reduction:('T -> 'T -> 'T) -> list:'T list -> 'T"]]}""" + "\n" + """{"word":"reduceBack","info":[["val reduceBack : reduction:('T -> 'T -> 'T) -> list:'T list -> 'T"]]}""" + "\n" + """{"word":"replicate","info":[["val replicate : count:int -> initial:'T -> 'T list"]]}""" + "\n" + """{"word":"rev","info":[["val rev : list:'T list -> 'T list"]]}""" + "\n" + """{"word":"scan","info":[["val scan : folder:('State -> 'T -> 'State) -> state:'State -> list:'T list -> 'State list"]]}""" + "\n" + """{"word":"scanBack","info":[["val scanBack : folder:('T -> 'State -> 'State) -> list:'T list -> state:'State -> 'State list"]]}""" + "\n" + """{"word":"singleton","info":[["val singleton : value:'T -> 'T list"]]}""" + "\n" + """{"word":"skip","info":[["val skip : count:int -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"skipWhile","info":[["val skipWhile : predicate:('T -> bool) -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"sortWith","info":[["val sortWith : comparer:('T -> 'T -> int) -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"sortBy","info":[["val sortBy : projection:('T -> 'Key) -> list:'T list -> 'T list (requires comparison)"]]}""" + "\n" + """{"word":"sort","info":[["val sort : list:'T list -> 'T list (requires comparison)"]]}""" + "\n" + """{"word":"splitAt","info":[["val splitAt : index:int -> list:'T list -> 'T list * 'T list"]]}""" + "\n" + """{"word":"sortByDescending","info":[["val sortByDescending : projection:('T -> 'Key) -> list:'T list -> 'T list (requires comparison)"]]}""" + "\n" + """{"word":"sortDescending","info":[["val sortDescending : list:'T list -> 'T list (requires comparison)"]]}""" + "\n" + """{"word":"sum","info":[["val sum : list:'T list -> 'T (requires member ( + ) and member get_Zero)"]]}""" + "\n" + """{"word":"sumBy","info":[["val sumBy : projection:('T -> 'U) -> list:'T list -> 'U (requires member ( + ) and member get_Zero)"]]}""" + "\n" + """{"word":"tail","info":[["val tail : list:'T list -> 'T list"]]}""" + "\n" + """{"word":"take","info":[["val take : count:int -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"takeWhile","info":[["val takeWhile : predicate:('T -> bool) -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"toArray","info":[["val toArray : list:'T list -> 'T []"]]}""" + "\n" + """{"word":"toSeq","info":[["val toSeq : list:'T list -> seq<'T>"]]}""" + "\n" + """{"word":"tryHead","info":[["val tryHead : list:'T list -> 'T option"]]}""" + "\n" + """{"word":"truncate","info":[["val truncate : count:int -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"tryPick","info":[["val tryPick : chooser:('T -> 'U option) -> list:'T list -> 'U option"]]}""" + "\n" + """{"word":"tryFind","info":[["val tryFind : predicate:('T -> bool) -> list:'T list -> 'T option"]]}""" + "\n" + """{"word":"tryFindBack","info":[["val tryFindBack : predicate:('T -> bool) -> list:'T list -> 'T option"]]}""" + "\n" + """{"word":"tryFindIndex","info":[["val tryFindIndex : predicate:('T -> bool) -> list:'T list -> int option"]]}""" + "\n" + """{"word":"tryItem","info":[["val tryItem : index:int -> list:'T list -> 'T option"]]}""" + "\n" + """{"word":"tryFindIndexBack","info":[["val tryFindIndexBack : predicate:('T -> bool) -> list:'T list -> int option"]]}""" + "\n" + """{"word":"unfold","info":[["val unfold : generator:('State -> ('T * 'State) option) -> state:'State -> 'T list"]]}""" + "\n" + """{"word":"unzip","info":[["val unzip : list:('T1 * 'T2) list -> 'T1 list * 'T2 list"]]}""" + "\n" + """{"word":"unzip3","info":[["val unzip3 : list:('T1 * 'T2 * 'T3) list -> 'T1 list * 'T2 list * 'T3 list"]]}""" + "\n" + """{"word":"where","info":[["val where : predicate:('T -> bool) -> list:'T list -> 'T list"]]}""" + "\n" + """{"word":"windowed","info":[["val windowed : windowSize:int -> list:'T list -> 'T list list"]]}""" + "\n" + """{"word":"zip","info":[["val zip : list1:'T1 list -> list2:'T2 list -> ('T1 * 'T2) list"]]}""" + "\n" + """{"word":"zip3","info":[["val zip3 : list1:'T1 list -> list2:'T2 list -> list3:'T3 list -> ('T1 * 'T2 * 'T3) list"]]}""" + "\n" + """{"word":"Empty","info":[["property List.Empty: 'T list"]]}""" + "\n" + """{"word":"Cons","info":[["static member List.Cons : head:'T * tail:'T list -> 'T list"]]}"""
            "Map","""{"word":"add","info":[["val add : key:'Key -> value:'T -> table:Map<'Key,'T> -> Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"ofList","info":[["val ofList : elements:('Key * 'T) list -> Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"ofArray","info":[["val ofArray : elements:('Key * 'T) [] -> Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"ofSeq","info":[["val ofSeq : elements:seq<'Key * 'T> -> Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"toSeq","info":[["val toSeq : table:Map<'Key,'T> -> seq<'Key * 'T> (requires comparison)"]]}""" + "\n" + """{"word":"toList","info":[["val toList : table:Map<'Key,'T> -> ('Key * 'T) list (requires comparison)"]]}""" + "\n" + """{"word":"toArray","info":[["val toArray : table:Map<'Key,'T> -> ('Key * 'T) [] (requires comparison)"]]}""" + "\n" + """{"word":"isEmpty","info":[["val isEmpty : table:Map<'Key,'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"empty","info":[["val empty<'Key,'T (requires comparison)> : Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"find","info":[["val find : key:'Key -> table:Map<'Key,'T> -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"tryPick","info":[["val tryPick : chooser:('Key -> 'T -> 'U option) -> table:Map<'Key,'T> -> 'U option (requires comparison)"]]}""" + "\n" + """{"word":"pick","info":[["val pick : chooser:('Key -> 'T -> 'U option) -> table:Map<'Key,'T> -> 'U (requires comparison)"]]}""" + "\n" + """{"word":"foldBack","info":[["val foldBack : folder:('Key -> 'T -> 'State -> 'State) -> table:Map<'Key,'T> -> state:'State -> 'State (requires comparison)"]]}""" + "\n" + """{"word":"fold","info":[["val fold : folder:('State -> 'Key -> 'T -> 'State) -> state:'State -> table:Map<'Key,'T> -> 'State (requires comparison)"]]}""" + "\n" + """{"word":"iter","info":[["val iter : action:('Key -> 'T -> unit) -> table:Map<'Key,'T> -> unit (requires comparison)"]]}""" + "\n" + """{"word":"exists","info":[["val exists : predicate:('Key -> 'T -> bool) -> table:Map<'Key,'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"filter","info":[["val filter : predicate:('Key -> 'T -> bool) -> table:Map<'Key,'T> -> Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"forall","info":[["val forall : predicate:('Key -> 'T -> bool) -> table:Map<'Key,'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"map","info":[["val map : mapping:('Key -> 'T -> 'U) -> table:Map<'Key,'T> -> Map<'Key,'U> (requires comparison)"]]}""" + "\n" + """{"word":"containsKey","info":[["val containsKey : key:'Key -> table:Map<'Key,'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"partition","info":[["val partition : predicate:('Key -> 'T -> bool) -> table:Map<'Key,'T> -> Map<'Key,'T> * Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"remove","info":[["val remove : key:'Key -> table:Map<'Key,'T> -> Map<'Key,'T> (requires comparison)"]]}""" + "\n" + """{"word":"tryFind","info":[["val tryFind : key:'Key -> table:Map<'Key,'T> -> 'T option (requires comparison)"]]}""" + "\n" + """{"word":"findKey","info":[["val findKey : predicate:('Key -> 'T -> bool) -> table:Map<'Key,'T> -> 'Key (requires comparison)"]]}""" + "\n" + """{"word":"tryFindKey","info":[["val tryFindKey : predicate:('Key -> 'T -> bool) -> table:Map<'Key,'T> -> 'Key option (requires comparison)"]]}""" + "\n" + """{"word":"count","info":[["val count : table:Map<'Key,'T> -> int (requires comparison)"]]}"""
            "Observable","""{"word":"merge","info":[["val merge : source1:System.IObservable<'T> -> source2:System.IObservable<'T> -> System.IObservable<'T>"]]}""" + "\n" + """{"word":"map","info":[["val map : mapping:('T -> 'U) -> source:System.IObservable<'T> -> System.IObservable<'U>"]]}""" + "\n" + """{"word":"filter","info":[["val filter : predicate:('T -> bool) -> source:System.IObservable<'T> -> System.IObservable<'T>"]]}""" + "\n" + """{"word":"partition","info":[["val partition : predicate:('T -> bool) -> source:System.IObservable<'T> -> System.IObservable<'T> * System.IObservable<'T>"]]}""" + "\n" + """{"word":"split","info":[["val split : splitter:('T -> Choice<'U1,'U2>) -> source:System.IObservable<'T> -> System.IObservable<'U1> * System.IObservable<'U2>"]]}""" + "\n" + """{"word":"choose","info":[["val choose : chooser:('T -> 'U option) -> source:System.IObservable<'T> -> System.IObservable<'U>"]]}""" + "\n" + """{"word":"scan","info":[["val scan : collector:('U -> 'T -> 'U) -> state:'U -> source:System.IObservable<'T> -> System.IObservable<'U>"]]}""" + "\n" + """{"word":"add","info":[["val add : callback:('T -> unit) -> source:System.IObservable<'T> -> unit"]]}""" + "\n" + """{"word":"subscribe","info":[["val subscribe : callback:('T -> unit) -> source:System.IObservable<'T> -> System.IDisposable"]]}""" + "\n" + """{"word":"pairwise","info":[["val pairwise : source:System.IObservable<'T> -> System.IObservable<'T * 'T>"]]}"""
            "Option","""{"word":"isSome","info":[["val isSome : option:'T option -> bool"]]}""" + "\n" + """{"word":"isNone","info":[["val isNone : option:'T option -> bool"]]}""" + "\n" + """{"word":"defaultValue","info":[["val defaultValue : value:'T -> option:'T option -> 'T"]]}""" + "\n" + """{"word":"defaultWith","info":[["val defaultWith : defThunk:(unit -> 'T) -> option:'T option -> 'T"]]}""" + "\n" + """{"word":"orElse","info":[["val orElse : ifNone:'T option -> option:'T option -> 'T option"]]}""" + "\n" + """{"word":"orElseWith","info":[["val orElseWith : ifNoneThunk:(unit -> 'T option) -> option:'T option -> 'T option"]]}""" + "\n" + """{"word":"get","info":[["val get : option:'T option -> 'T"]]}""" + "\n" + """{"word":"count","info":[["val count : option:'T option -> int"]]}""" + "\n" + """{"word":"fold","info":[["val fold : folder:('State -> 'T -> 'State) -> state:'State -> option:'T option -> 'State"]]}""" + "\n" + """{"word":"foldBack","info":[["val foldBack : folder:('T -> 'State -> 'State) -> option:'T option -> state:'State -> 'State"]]}""" + "\n" + """{"word":"exists","info":[["val exists : predicate:('T -> bool) -> option:'T option -> bool"]]}""" + "\n" + """{"word":"forall","info":[["val forall : predicate:('T -> bool) -> option:'T option -> bool"]]}""" + "\n" + """{"word":"contains","info":[["val contains : value:'T -> option:'T option -> bool (requires equality)"]]}""" + "\n" + """{"word":"iter","info":[["val iter : action:('T -> unit) -> option:'T option -> unit"]]}""" + "\n" + """{"word":"map","info":[["val map : mapping:('T -> 'U) -> option:'T option -> 'U option"]]}""" + "\n" + """{"word":"map2","info":[["val map2 : mapping:('T1 -> 'T2 -> 'U) -> 'T1 option -> 'T2 option -> 'U option"]]}""" + "\n" + """{"word":"map3","info":[["val map3 : mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> 'T1 option -> 'T2 option -> 'T3 option -> 'U option"]]}""" + "\n" + """{"word":"bind","info":[["val bind : binder:('T -> 'U option) -> option:'T option -> 'U option"]]}""" + "\n" + """{"word":"flatten","info":[["val flatten : option:'T option option -> 'T option"]]}""" + "\n" + """{"word":"filter","info":[["val filter : predicate:('T -> bool) -> option:'T option -> 'T option"]]}""" + "\n" + """{"word":"toArray","info":[["val toArray : option:'T option -> 'T []"]]}""" + "\n" + """{"word":"toList","info":[["val toList : option:'T option -> 'T list"]]}""" + "\n" + """{"word":"toNullable","info":[["val toNullable : option:'T option -> System.Nullable<'T> (requires default constructor and value type and 'T :> System.ValueType)"]]}""" + "\n" + """{"word":"ofNullable","info":[["val ofNullable : value:System.Nullable<'T> -> 'T option (requires default constructor and value type and 'T :> System.ValueType)"]]}""" + "\n" + """{"word":"ofObj","info":[["val ofObj : value:'T -> 'T option (requires 'T : null)"]]}""" + "\n" + """{"word":"toObj","info":[["val toObj : value:'T option -> 'T (requires 'T : null)"]]}""" + "\n" + """{"word":"None","info":[["union case Option.None: Option<'T>"],["property Option.None: 'T option"]]}""" + "\n" + """{"word":"Some","info":[["union case Option.Some: Value: 'T -> Option<'T>"],["static member Option.Some : value:'T -> 'T option"]]}""" + "\n" + """{"word":"op_Implicit","info":[["static member Option.op_Implicit : value:'T -> 'T option"]]}"""
            "Seq","""{"word":"allPairs","info":[["val allPairs : source1:seq<'T1> -> source2:seq<'T2> -> seq<'T1 * 'T2>"]]}""" + "\n" + """{"word":"append","info":[["val append : source1:seq<'T> -> source2:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"average","info":[["val average : source:seq<'T> -> 'T (requires member ( + ) and member DivideByInt and member get_Zero)"]]}""" + "\n" + """{"word":"averageBy","info":[["val averageBy : projection:('T -> 'U) -> source:seq<'T> -> 'U (requires member ( + ) and member DivideByInt and member get_Zero)"]]}""" + "\n" + """{"word":"cache","info":[["val cache : source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"cast","info":[["val cast : source:System.Collections.IEnumerable -> seq<'T>"]]}""" + "\n" + """{"word":"choose","info":[["val choose : chooser:('T -> 'U option) -> source:seq<'T> -> seq<'U>"]]}""" + "\n" + """{"word":"chunkBySize","info":[["val chunkBySize : chunkSize:int -> source:seq<'T> -> seq<'T []>"]]}""" + "\n" + """{"word":"collect","info":[["val collect : mapping:('T -> #seq<'U>) -> source:seq<'T> -> seq<'U>"]]}""" + "\n" + """{"word":"compareWith","info":[["val compareWith : comparer:('T -> 'T -> int) -> source1:seq<'T> -> source2:seq<'T> -> int"]]}""" + "\n" + """{"word":"concat","info":[["val concat : sources:seq<#seq<'T>> -> seq<'T>"]]}""" + "\n" + """{"word":"contains","info":[["val contains : value:'T -> source:seq<'T> -> bool (requires equality)"]]}""" + "\n" + """{"word":"countBy","info":[["val countBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'Key * int> (requires equality)"]]}""" + "\n" + """{"word":"delay","info":[["val delay : generator:(unit -> seq<'T>) -> seq<'T>"]]}""" + "\n" + """{"word":"distinct","info":[["val distinct : source:seq<'T> -> seq<'T> (requires equality)"]]}""" + "\n" + """{"word":"distinctBy","info":[["val distinctBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> (requires equality)"]]}""" + "\n" + """{"word":"splitInto","info":[["val splitInto : count:int -> source:seq<'T> -> seq<'T []>"]]}""" + "\n" + """{"word":"empty","info":[["val empty<'T> : seq<'T>"]]}""" + "\n" + """{"word":"except","info":[["val except : itemsToExclude:seq<'T> -> source:seq<'T> -> seq<'T> (requires equality)"]]}""" + "\n" + """{"word":"exists","info":[["val exists : predicate:('T -> bool) -> source:seq<'T> -> bool"]]}""" + "\n" + """{"word":"exists2","info":[["val exists2 : predicate:('T1 -> 'T2 -> bool) -> source1:seq<'T1> -> source2:seq<'T2> -> bool"]]}""" + "\n" + """{"word":"filter","info":[["val filter : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"where","info":[["val where : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"find","info":[["val find : predicate:('T -> bool) -> source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"findBack","info":[["val findBack : predicate:('T -> bool) -> source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"findIndex","info":[["val findIndex : predicate:('T -> bool) -> source:seq<'T> -> int"]]}""" + "\n" + """{"word":"findIndexBack","info":[["val findIndexBack : predicate:('T -> bool) -> source:seq<'T> -> int"]]}""" + "\n" + """{"word":"fold","info":[["val fold : folder:('State -> 'T -> 'State) -> state:'State -> source:seq<'T> -> 'State"]]}""" + "\n" + """{"word":"fold2","info":[["val fold2 : folder:('State -> 'T1 -> 'T2 -> 'State) -> state:'State -> source1:seq<'T1> -> source2:seq<'T2> -> 'State"]]}""" + "\n" + """{"word":"foldBack","info":[["val foldBack : folder:('T -> 'State -> 'State) -> source:seq<'T> -> state:'State -> 'State"]]}""" + "\n" + """{"word":"foldBack2","info":[["val foldBack2 : folder:('T1 -> 'T2 -> 'State -> 'State) -> source1:seq<'T1> -> source2:seq<'T2> -> state:'State -> 'State"]]}""" + "\n" + """{"word":"forall","info":[["val forall : predicate:('T -> bool) -> source:seq<'T> -> bool"]]}""" + "\n" + """{"word":"forall2","info":[["val forall2 : predicate:('T1 -> 'T2 -> bool) -> source1:seq<'T1> -> source2:seq<'T2> -> bool"]]}""" + "\n" + """{"word":"groupBy","info":[["val groupBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'Key * seq<'T>> (requires equality)"]]}""" + "\n" + """{"word":"head","info":[["val head : source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"tryHead","info":[["val tryHead : source:seq<'T> -> 'T option"]]}""" + "\n" + """{"word":"last","info":[["val last : source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"tryLast","info":[["val tryLast : source:seq<'T> -> 'T option"]]}""" + "\n" + """{"word":"exactlyOne","info":[["val exactlyOne : source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"isEmpty","info":[["val isEmpty : source:seq<'T> -> bool"]]}""" + "\n" + """{"word":"indexed","info":[["val indexed : source:seq<'T> -> seq<int * 'T>"]]}""" + "\n" + """{"word":"init","info":[["val init : count:int -> initializer:(int -> 'T) -> seq<'T>"]]}""" + "\n" + """{"word":"initInfinite","info":[["val initInfinite : initializer:(int -> 'T) -> seq<'T>"]]}""" + "\n" + """{"word":"item","info":[["val item : index:int -> source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"iter","info":[["val iter : action:('T -> unit) -> source:seq<'T> -> unit"]]}""" + "\n" + """{"word":"iteri","info":[["val iteri : action:(int -> 'T -> unit) -> source:seq<'T> -> unit"]]}""" + "\n" + """{"word":"iter2","info":[["val iter2 : action:('T1 -> 'T2 -> unit) -> source1:seq<'T1> -> source2:seq<'T2> -> unit"]]}""" + "\n" + """{"word":"iteri2","info":[["val iteri2 : action:(int -> 'T1 -> 'T2 -> unit) -> source1:seq<'T1> -> source2:seq<'T2> -> unit"]]}""" + "\n" + """{"word":"length","info":[["val length : source:seq<'T> -> int"]]}""" + "\n" + """{"word":"map","info":[["val map : mapping:('T -> 'U) -> source:seq<'T> -> seq<'U>"]]}""" + "\n" + """{"word":"map2","info":[["val map2 : mapping:('T1 -> 'T2 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> seq<'U>"]]}""" + "\n" + """{"word":"mapFold","info":[["val mapFold : mapping:('State -> 'T -> 'Result * 'State) -> state:'State -> source:seq<'T> -> seq<'Result> * 'State"]]}""" + "\n" + """{"word":"mapFoldBack","info":[["val mapFoldBack : mapping:('T -> 'State -> 'Result * 'State) -> source:seq<'T> -> state:'State -> seq<'Result> * 'State"]]}""" + "\n" + """{"word":"map3","info":[["val map3 : mapping:('T1 -> 'T2 -> 'T3 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> source3:seq<'T3> -> seq<'U>"]]}""" + "\n" + """{"word":"mapi","info":[["val mapi : mapping:(int -> 'T -> 'U) -> source:seq<'T> -> seq<'U>"]]}""" + "\n" + """{"word":"mapi2","info":[["val mapi2 : mapping:(int -> 'T1 -> 'T2 -> 'U) -> source1:seq<'T1> -> source2:seq<'T2> -> seq<'U>"]]}""" + "\n" + """{"word":"max","info":[["val max : source:seq<'T> -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"maxBy","info":[["val maxBy : projection:('T -> 'U) -> source:seq<'T> -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"min","info":[["val min : source:seq<'T> -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"minBy","info":[["val minBy : projection:('T -> 'U) -> source:seq<'T> -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"ofArray","info":[["val ofArray : source:'T [] -> seq<'T>"]]}""" + "\n" + """{"word":"ofList","info":[["val ofList : source:'T list -> seq<'T>"]]}""" + "\n" + """{"word":"pairwise","info":[["val pairwise : source:seq<'T> -> seq<'T * 'T>"]]}""" + "\n" + """{"word":"permute","info":[["val permute : indexMap:(int -> int) -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"pick","info":[["val pick : chooser:('T -> 'U option) -> source:seq<'T> -> 'U"]]}""" + "\n" + """{"word":"readonly","info":[["val readonly : source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"reduce","info":[["val reduce : reduction:('T -> 'T -> 'T) -> source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"replicate","info":[["val replicate : count:int -> initial:'T -> seq<'T>"]]}""" + "\n" + """{"word":"reduceBack","info":[["val reduceBack : reduction:('T -> 'T -> 'T) -> source:seq<'T> -> 'T"]]}""" + "\n" + """{"word":"rev","info":[["val rev : source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"scan","info":[["val scan : folder:('State -> 'T -> 'State) -> state:'State -> source:seq<'T> -> seq<'State>"]]}""" + "\n" + """{"word":"scanBack","info":[["val scanBack : folder:('T -> 'State -> 'State) -> source:seq<'T> -> state:'State -> seq<'State>"]]}""" + "\n" + """{"word":"singleton","info":[["val singleton : value:'T -> seq<'T>"]]}""" + "\n" + """{"word":"skip","info":[["val skip : count:int -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"skipWhile","info":[["val skipWhile : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"sort","info":[["val sort : source:seq<'T> -> seq<'T> (requires comparison)"]]}""" + "\n" + """{"word":"sortWith","info":[["val sortWith : comparer:('T -> 'T -> int) -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"sortBy","info":[["val sortBy : projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> (requires comparison)"]]}""" + "\n" + """{"word":"sortDescending","info":[["val sortDescending : source:seq<'T> -> seq<'T> (requires comparison)"]]}""" + "\n" + """{"word":"sortByDescending","info":[["val sortByDescending : projection:('T -> 'Key) -> source:seq<'T> -> seq<'T> (requires comparison)"]]}""" + "\n" + """{"word":"sum","info":[["val sum : source:seq<'T> -> 'T (requires member ( + ) and member get_Zero)"]]}""" + "\n" + """{"word":"sumBy","info":[["val sumBy : projection:('T -> 'U) -> source:seq<'T> -> 'U (requires member ( + ) and member get_Zero)"]]}""" + "\n" + """{"word":"tail","info":[["val tail : source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"take","info":[["val take : count:int -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"takeWhile","info":[["val takeWhile : predicate:('T -> bool) -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"toArray","info":[["val toArray : source:seq<'T> -> 'T []"]]}""" + "\n" + """{"word":"toList","info":[["val toList : source:seq<'T> -> 'T list"]]}""" + "\n" + """{"word":"tryFind","info":[["val tryFind : predicate:('T -> bool) -> source:seq<'T> -> 'T option"]]}""" + "\n" + """{"word":"tryFindBack","info":[["val tryFindBack : predicate:('T -> bool) -> source:seq<'T> -> 'T option"]]}""" + "\n" + """{"word":"tryFindIndex","info":[["val tryFindIndex : predicate:('T -> bool) -> source:seq<'T> -> int option"]]}""" + "\n" + """{"word":"tryItem","info":[["val tryItem : index:int -> source:seq<'T> -> 'T option"]]}""" + "\n" + """{"word":"tryFindIndexBack","info":[["val tryFindIndexBack : predicate:('T -> bool) -> source:seq<'T> -> int option"]]}""" + "\n" + """{"word":"tryPick","info":[["val tryPick : chooser:('T -> 'U option) -> source:seq<'T> -> 'U option"]]}""" + "\n" + """{"word":"truncate","info":[["val truncate : count:int -> source:seq<'T> -> seq<'T>"]]}""" + "\n" + """{"word":"unfold","info":[["val unfold : generator:('State -> ('T * 'State) option) -> state:'State -> seq<'T>"]]}""" + "\n" + """{"word":"windowed","info":[["val windowed : windowSize:int -> source:seq<'T> -> seq<'T []>"]]}""" + "\n" + """{"word":"zip","info":[["val zip : source1:seq<'T1> -> source2:seq<'T2> -> seq<'T1 * 'T2>"]]}""" + "\n" + """{"word":"zip3","info":[["val zip3 : source1:seq<'T1> -> source2:seq<'T2> -> source3:seq<'T3> -> seq<'T1 * 'T2 * 'T3>"]]}"""
            "Set","""{"word":"empty","info":[["val empty<'T (requires comparison)> : Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"singleton","info":[["val singleton : value:'T -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"add","info":[["val add : value:'T -> set:Set<'T> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"contains","info":[["val contains : element:'T -> set:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"isSubset","info":[["val isSubset : set1:Set<'T> -> set2:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"isProperSubset","info":[["val isProperSubset : set1:Set<'T> -> set2:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"isSuperset","info":[["val isSuperset : set1:Set<'T> -> set2:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"isProperSuperset","info":[["val isProperSuperset : set1:Set<'T> -> set2:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"count","info":[["val count : set:Set<'T> -> int (requires comparison)"]]}""" + "\n" + """{"word":"exists","info":[["val exists : predicate:('T -> bool) -> set:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"filter","info":[["val filter : predicate:('T -> bool) -> set:Set<'T> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"map","info":[["val map : mapping:('T -> 'U) -> set:Set<'T> -> Set<'U> (requires comparison and comparison)"]]}""" + "\n" + """{"word":"fold","info":[["val fold : folder:('State -> 'T -> 'State) -> state:'State -> set:Set<'T> -> 'State (requires comparison)"]]}""" + "\n" + """{"word":"foldBack","info":[["val foldBack : folder:('T -> 'State -> 'State) -> set:Set<'T> -> state:'State -> 'State (requires comparison)"]]}""" + "\n" + """{"word":"forall","info":[["val forall : predicate:('T -> bool) -> set:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"intersect","info":[["val intersect : set1:Set<'T> -> set2:Set<'T> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"intersectMany","info":[["val intersectMany : sets:seq<Set<'T>> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"union","info":[["val union : set1:Set<'T> -> set2:Set<'T> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"unionMany","info":[["val unionMany : sets:seq<Set<'T>> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"isEmpty","info":[["val isEmpty : set:Set<'T> -> bool (requires comparison)"]]}""" + "\n" + """{"word":"iter","info":[["val iter : action:('T -> unit) -> set:Set<'T> -> unit (requires comparison)"]]}""" + "\n" + """{"word":"partition","info":[["val partition : predicate:('T -> bool) -> set:Set<'T> -> Set<'T> * Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"remove","info":[["val remove : value:'T -> set:Set<'T> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"minElement","info":[["val minElement : set:Set<'T> -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"maxElement","info":[["val maxElement : set:Set<'T> -> 'T (requires comparison)"]]}""" + "\n" + """{"word":"ofList","info":[["val ofList : elements:'T list -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"toList","info":[["val toList : set:Set<'T> -> 'T list (requires comparison)"]]}""" + "\n" + """{"word":"ofArray","info":[["val ofArray : array:'T [] -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"toArray","info":[["val toArray : set:Set<'T> -> 'T [] (requires comparison)"]]}""" + "\n" + """{"word":"toSeq","info":[["val toSeq : set:Set<'T> -> seq<'T> (requires comparison)"]]}""" + "\n" + """{"word":"ofSeq","info":[["val ofSeq : elements:seq<'T> -> Set<'T> (requires comparison)"]]}""" + "\n" + """{"word":"difference","info":[["val difference : set1:Set<'T> -> set2:Set<'T> -> Set<'T> (requires comparison)"]]}"""
            "System","""{"word":"Numerics","info":[["namespace System.Numerics"]]}""" + "\n" + """{"word":"Windows","info":[["namespace System.Windows"]]}""" + "\n" + """{"word":"Resources","info":[["namespace System.Resources"]]}""" + "\n" + """{"word":"Web","info":[["namespace System.Web"]]}""" + "\n" + """{"word":"Data","info":[["namespace System.Data"]]}""" + "\n" + """{"word":"Threading","info":[["namespace System.Threading"]]}""" + "\n" + """{"word":"Security","info":[["namespace System.Security"]]}""" + "\n" + """{"word":"Runtime","info":[["namespace System.Runtime"]]}""" + "\n" + """{"word":"Linq","info":[["namespace System.Linq"]]}""" + "\n" + """{"word":"IO","info":[["namespace System.IO"]]}""" + "\n" + """{"word":"Dynamic","info":[["namespace System.Dynamic"]]}""" + "\n" + """{"word":"Collections","info":[["namespace System.Collections"]]}""" + "\n" + """{"word":"Drawing","info":[["namespace System.Drawing"]]}""" + "\n" + """{"word":"Xml","info":[["namespace System.Xml"]]}""" + "\n" + """{"word":"Timers","info":[["namespace System.Timers"]]}""" + "\n" + """{"word":"Text","info":[["namespace System.Text"]]}""" + "\n" + """{"word":"Net","info":[["namespace System.Net"]]}""" + "\n" + """{"word":"Media","info":[["namespace System.Media"]]}""" + "\n" + """{"word":"Diagnostics","info":[["namespace System.Diagnostics"]]}""" + "\n" + """{"word":"Configuration","info":[["namespace System.Configuration"]]}""" + "\n" + """{"word":"ComponentModel","info":[["namespace System.ComponentModel"]]}""" + "\n" + """{"word":"CodeDom","info":[["namespace System.CodeDom"]]}""" + "\n" + """{"word":"Reflection","info":[["namespace System.Reflection"]]}""" + "\n" + """{"word":"Globalization","info":[["namespace System.Globalization"]]}""" + "\n" + """{"word":"Deployment","info":[["namespace System.Deployment"]]}""" + "\n" + """{"word":"Tuple","info":[[],[],[],[],[],[],["type Tuple =\n  static member Create<'T1> : item1:'T1 -> Tuple<'T1> + 7 overloads"],["type Tuple<'T1> =\n  new : item1:'T1 -> Tuple<'T1>\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member Item1 : 'T1\n  member ToString : unit -> string"],["type Tuple<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'TRest> =\n  new : item1:'T1 * item2:'T2 * item3:'T3 * item4:'T4 * item5:'T5 * item6:'T6 * item7:'T7 * rest:'TRest -> Tuple<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'TRest>\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member Item1 : 'T1\n  member Item2 : 'T2\n  member Item3 : 'T3\n  member Item4 : 'T4\n  member Item5 : 'T5\n  member Item6 : 'T6\n  member Item7 : 'T7\n  ..."],["System.Tuple(item1: 'T1) : System.Tuple<'T1>"],["System.Tuple(item1: 'T1, item2: 'T2) : 'T1 * 'T2"],["System.Tuple(item1: 'T1, item2: 'T2, item3: 'T3) : 'T1 * 'T2 * 'T3"],["System.Tuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4) : 'T1 * 'T2 * 'T3 * 'T4"],["System.Tuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5) : 'T1 * 'T2 * 'T3 * 'T4 * 'T5"],["System.Tuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5, item6: 'T6) : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6"],["System.Tuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5, item6: 'T6, item7: 'T7) : 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7"],["System.Tuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5, item6: 'T6, item7: 'T7, rest: 'TRest) : System.Tuple<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'TRest>"]]}""" + "\n" + """{"word":"ValueTuple","info":[[],[],[],[],[],[],["type ValueTuple =\n  struct\n    member CompareTo : other:ValueTuple -> int\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member ToString : unit -> string\n    static member Create : unit -> ValueTuple + 8 overloads\n  end"],["type ValueTuple<'T1> =\n  struct\n    new : item1:'T1 -> ValueTuple<'T1>\n    val Item1 : 'T1\n    member CompareTo : other:ValueTuple<'T1> -> int\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member ToString : unit -> string\n  end"],["type ValueTuple<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'TRest (requires default constructor and value type and 'TRest :> ValueType)> =\n  struct\n    new : item1:'T1 * item2:'T2 * item3:'T3 * item4:'T4 * item5:'T5 * item6:'T6 * item7:'T7 * rest:'TRest -> ValueTuple<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'TRest>\n    val Item1 : 'T1\n    val Item2 : 'T2\n    val Item3 : 'T3\n    val Item4 : 'T4\n    val Item5 : 'T5\n    val Item6 : 'T6\n    val Item7 : 'T7\n    val Rest : 'TRest\n    member CompareTo : other:ValueTuple<'T1, 'T2, 'T3, 'T4, 'T5, 'T6, 'T7, 'TRest> -> int\n    ...\n  end"],["System.ValueTuple ()","System.ValueTuple(item1: 'T1) : System.ValueTuple<'T1>"],["System.ValueTuple(item1: 'T1, item2: 'T2) : struct ('T1 * 'T2)"],["System.ValueTuple(item1: 'T1, item2: 'T2, item3: 'T3) : struct ('T1 * 'T2 * 'T3)"],["System.ValueTuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4) : struct ('T1 * 'T2 * 'T3 * 'T4)"],["System.ValueTuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5) : struct ('T1 * 'T2 * 'T3 * 'T4 * 'T5)"],["System.ValueTuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5, item6: 'T6) : struct ('T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6)"],["System.ValueTuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5, item6: 'T6, item7: 'T7) : struct ('T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7)"],["System.ValueTuple ()","System.ValueTuple(item1: 'T1, item2: 'T2, item3: 'T3, item4: 'T4, item5: 'T5, item6: 'T6, item7: 'T7, rest: 'TRest) : System.ValueTuple<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'TRest>"]]}""" + "\n" + """{"word":"UriTypeConverter","info":[["type UriTypeConverter =\n  inherit TypeConverter\n  new : unit -> UriTypeConverter\n  member CanConvertFrom : context:ITypeDescriptorContext * sourceType:Type -> bool\n  member CanConvertTo : context:ITypeDescriptorContext * destinationType:Type -> bool\n  member ConvertFrom : context:ITypeDescriptorContext * culture:CultureInfo * value:obj -> obj\n  member ConvertTo : context:ITypeDescriptorContext * culture:CultureInfo * value:obj * destinationType:Type -> obj\n  member IsValid : context:ITypeDescriptorContext * value:obj -> bool"],["System.UriTypeConverter() : System.UriTypeConverter"]]}""" + "\n" + """{"word":"UriParser","info":[["type UriParser =\n  static member IsKnownScheme : schemeName:string -> bool\n  static member Register : uriParser:UriParser * schemeName:string * defaultPort:int -> unit"]]}""" + "\n" + """{"word":"NetTcpStyleUriParser","info":[["type NetTcpStyleUriParser =\n  inherit UriParser\n  new : unit -> NetTcpStyleUriParser"],["System.NetTcpStyleUriParser() : System.NetTcpStyleUriParser"]]}""" + "\n" + """{"word":"NetPipeStyleUriParser","info":[["type NetPipeStyleUriParser =\n  inherit UriParser\n  new : unit -> NetPipeStyleUriParser"],["System.NetPipeStyleUriParser() : System.NetPipeStyleUriParser"]]}""" + "\n" + """{"word":"LdapStyleUriParser","info":[["type LdapStyleUriParser =\n  inherit UriParser\n  new : unit -> LdapStyleUriParser"],["System.LdapStyleUriParser() : System.LdapStyleUriParser"]]}""" + "\n" + """{"word":"GopherStyleUriParser","info":[["type GopherStyleUriParser =\n  inherit UriParser\n  new : unit -> GopherStyleUriParser"],["System.GopherStyleUriParser() : System.GopherStyleUriParser"]]}""" + "\n" + """{"word":"NewsStyleUriParser","info":[["type NewsStyleUriParser =\n  inherit UriParser\n  new : unit -> NewsStyleUriParser"],["System.NewsStyleUriParser() : System.NewsStyleUriParser"]]}""" + "\n" + """{"word":"FileStyleUriParser","info":[["type FileStyleUriParser =\n  inherit UriParser\n  new : unit -> FileStyleUriParser"],["System.FileStyleUriParser() : System.FileStyleUriParser"]]}""" + "\n" + """{"word":"FtpStyleUriParser","info":[["type FtpStyleUriParser =\n  inherit UriParser\n  new : unit -> FtpStyleUriParser"],["System.FtpStyleUriParser() : System.FtpStyleUriParser"]]}""" + "\n" + """{"word":"HttpStyleUriParser","info":[["type HttpStyleUriParser =\n  inherit UriParser\n  new : unit -> HttpStyleUriParser"],["System.HttpStyleUriParser() : System.HttpStyleUriParser"]]}""" + "\n" + """{"word":"UriHostNameType","info":[["type UriHostNameType =\n  | Unknown = 0\n  | Basic = 1\n  | Dns = 2\n  | IPv4 = 3\n  | IPv6 = 4"]]}""" + "\n" + """{"word":"UriIdnScope","info":[["type UriIdnScope =\n  | None = 0\n  | AllExceptIntranet = 1\n  | All = 2"]]}""" + "\n" + """{"word":"UriFormat","info":[["type UriFormat =\n  | UriEscaped = 1\n  | Unescaped = 2\n  | SafeUnescaped = 3"]]}""" + "\n" + """{"word":"UriComponents","info":[["type UriComponents =\n  | Scheme = 1\n  | UserInfo = 2\n  | Host = 4\n  | Port = 8\n  | Path = 16\n  | Query = 32\n  | Fragment = 64\n  | StrongPort = 128\n  | NormalizedHost = 256\n  | KeepDelimiter = 1073741824\n  ..."]]}""" + "\n" + """{"word":"UriKind","info":[["type UriKind =\n  | RelativeOrAbsolute = 0\n  | Absolute = 1\n  | Relative = 2"]]}""" + "\n" + """{"word":"UriPartial","info":[["type UriPartial =\n  | Scheme = 0\n  | Authority = 1\n  | Path = 2\n  | Query = 3"]]}""" + "\n" + """{"word":"UriFormatException","info":[["type UriFormatException =\n  inherit FormatException\n  new : unit -> UriFormatException + 2 overloads"],["System.UriFormatException() : System.UriFormatException","System.UriFormatException(textString: string) : System.UriFormatException","System.UriFormatException(textString: string, e: exn) : System.UriFormatException"]]}""" + "\n" + """{"word":"Uri","info":[["type Uri =\n  new : uriString:string -> Uri + 5 overloads\n  member AbsolutePath : string\n  member AbsoluteUri : string\n  member Authority : string\n  member DnsSafeHost : string\n  member Equals : comparand:obj -> bool\n  member Fragment : string\n  member GetComponents : components:UriComponents * format:UriFormat -> string\n  member GetHashCode : unit -> int\n  member GetLeftPart : part:UriPartial -> string\n  ..."],["System.Uri(uriString: string) : System.Uri","System.Uri(uriString: string, uriKind: System.UriKind) : System.Uri","System.Uri(baseUri: System.Uri, relativeUri: string) : System.Uri","System.Uri(baseUri: System.Uri, relativeUri: System.Uri) : System.Uri"]]}""" + "\n" + """{"word":"GenericUriParser","info":[["type GenericUriParser =\n  inherit UriParser\n  new : options:GenericUriParserOptions -> GenericUriParser"],["System.GenericUriParser(options: System.GenericUriParserOptions) : System.GenericUriParser"]]}""" + "\n" + """{"word":"GenericUriParserOptions","info":[["type GenericUriParserOptions =\n  | Default = 0\n  | GenericAuthority = 1\n  | AllowEmptyAuthority = 2\n  | NoUserInfo = 4\n  | NoPort = 8\n  | NoQuery = 16\n  | NoFragment = 32\n  | DontConvertPathBackslashes = 64\n  | DontCompressPath = 128\n  | DontUnescapePathDotsAndSlashes = 256\n  ..."]]}""" + "\n" + """{"word":"UriBuilder","info":[["type UriBuilder =\n  new : unit -> UriBuilder + 6 overloads\n  member Equals : rparam:obj -> bool\n  member Fragment : string with get, set\n  member GetHashCode : unit -> int\n  member Host : string with get, set\n  member Password : string with get, set\n  member Path : string with get, set\n  member Port : int with get, set\n  member Query : string with get, set\n  member Scheme : string with get, set\n  ..."],["System.UriBuilder() : System.UriBuilder","System.UriBuilder(uri: string) : System.UriBuilder","System.UriBuilder(uri: System.Uri) : System.UriBuilder","System.UriBuilder(schemeName: string, hostName: string) : System.UriBuilder","System.UriBuilder(scheme: string, host: string, portNumber: int) : System.UriBuilder","System.UriBuilder(scheme: string, host: string, port: int, pathValue: string) : System.UriBuilder","System.UriBuilder(scheme: string, host: string, port: int, path: string, extraValue: string) : System.UriBuilder"]]}""" + "\n" + """{"word":"WeakReference","info":[["type WeakReference =\n  new : target:obj -> WeakReference + 1 overload\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member IsAlive : bool\n  member Target : obj with get, set\n  member TrackResurrection : bool"],["type WeakReference<'T (requires reference type)> =\n  new : target:'T -> WeakReference<'T> + 1 overload\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member SetTarget : target:'T -> unit\n  member TryGetTarget : target:'T -> bool"],["System.WeakReference(target: obj) : System.WeakReference","System.WeakReference(target: obj, trackResurrection: bool) : System.WeakReference"],["System.WeakReference(target: 'T) : System.WeakReference<'T>","System.WeakReference(target: 'T, trackResurrection: bool) : System.WeakReference<'T>"]]}""" + "\n" + """{"word":"Void","info":[["type Void ="]]}""" + "\n" + """{"word":"ValueType","info":[["type ValueType =\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member ToString : unit -> string"]]}""" + "\n" + """{"word":"UIntPtr","info":[["type UIntPtr =\n  struct\n    new : value:uint64 -> unativeint + 2 overloads\n    member Equals : obj:obj -> bool\n    member GetHashCode : unit -> int\n    member ToPointer : unit -> unit\n    member ToString : unit -> string\n    member ToUInt32 : unit -> uint32\n    member ToUInt64 : unit -> uint64\n    static val Zero : unativeint\n    static member Add : pointer:unativeint * offset:int -> unativeint\n    static member Size : int\n    ...\n  end"],["System.UIntPtr ()","System.UIntPtr(value: uint64) : System.UIntPtr","System.UIntPtr(value: uint32) : System.UIntPtr","System.UIntPtr(value: nativeptr<unit>) : System.UIntPtr"]]}""" + "\n" + """{"word":"TypeCode","info":[["type TypeCode =\n  | Empty = 0\n  | Object = 1\n  | DBNull = 2\n  | Boolean = 3\n  | Char = 4\n  | SByte = 5\n  | Byte = 6\n  | Int16 = 7\n  | UInt16 = 8\n  | Int32 = 9\n  ..."]]}""" + "\n" + """{"word":"TimeZone","info":[["type TimeZone =\n  member DaylightName : string\n  member GetDaylightChanges : year:int -> DaylightTime\n  member GetUtcOffset : time:DateTime -> TimeSpan\n  member IsDaylightSavingTime : time:DateTime -> bool\n  member StandardName : string\n  member ToLocalTime : time:DateTime -> DateTime\n  member ToUniversalTime : time:DateTime -> DateTime\n  static member CurrentTimeZone : TimeZone\n  static member IsDaylightSavingTime : time:DateTime * daylightTimes:DaylightTime -> bool"]]}""" + "\n" + """{"word":"StringComparison","info":[["type StringComparison =\n  | CurrentCulture = 0\n  | CurrentCultureIgnoreCase = 1\n  | InvariantCulture = 2\n  | InvariantCultureIgnoreCase = 3\n  | Ordinal = 4\n  | OrdinalIgnoreCase = 5"]]}""" + "\n" + """{"word":"RuntimeTypeHandle","info":[["type RuntimeTypeHandle =\n  struct\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetModuleHandle : unit -> ModuleHandle\n    member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n    member Value : nativeint\n  end"]]}""" + "\n" + """{"word":"RuntimeMethodHandle","info":[["type RuntimeMethodHandle =\n  struct\n    member Equals : obj:obj -> bool + 1 overload\n    member GetFunctionPointer : unit -> nativeint\n    member GetHashCode : unit -> int\n    member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n    member Value : nativeint\n  end"]]}""" + "\n" + """{"word":"RuntimeFieldHandle","info":[["type RuntimeFieldHandle =\n  struct\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n    member Value : nativeint\n  end"]]}""" + "\n" + """{"word":"RuntimeArgumentHandle","info":[["type RuntimeArgumentHandle ="]]}""" + "\n" + """{"word":"ResolveEventHandler","info":[["type ResolveEventHandler =\n  delegate of obj * ResolveEventArgs -> Assembly"]]}""" + "\n" + """{"word":"ResolveEventArgs","info":[["type ResolveEventArgs =\n  inherit EventArgs\n  new : name:string -> ResolveEventArgs + 1 overload\n  member Name : string\n  member RequestingAssembly : Assembly"],["System.ResolveEventArgs(name: string) : System.ResolveEventArgs","System.ResolveEventArgs(name: string, requestingAssembly: System.Reflection.Assembly) : System.ResolveEventArgs"]]}""" + "\n" + """{"word":"PlatformID","info":[["type PlatformID =\n  | Win32S = 0\n  | Win32Windows = 1\n  | Win32NT = 2\n  | WinCE = 3\n  | Unix = 4\n  | Xbox = 5\n  | MacOSX = 6"]]}""" + "\n" + """{"word":"OperatingSystem","info":[["type OperatingSystem =\n  new : platform:PlatformID * version:Version -> OperatingSystem\n  member Clone : unit -> obj\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Platform : PlatformID\n  member ServicePack : string\n  member ToString : unit -> string\n  member Version : Version\n  member VersionString : string"],["System.OperatingSystem(platform: System.PlatformID, version: System.Version) : System.OperatingSystem"]]}""" + "\n" + """{"word":"Object","info":[["type Object =\n  new : unit -> obj\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member GetType : unit -> Type\n  member ToString : unit -> string\n  static member Equals : objA:obj * objB:obj -> bool\n  static member ReferenceEquals : objA:obj * objB:obj -> bool"],["System.Object() : System.Object"]]}""" + "\n" + """{"word":"Nullable","info":[["type Nullable =\n  static member Compare<'T> : n1:Nullable<'T> * n2:Nullable<'T> -> int\n  static member Equals<'T> : n1:Nullable<'T> * n2:Nullable<'T> -> bool\n  static member GetUnderlyingType : nullableType:Type -> Type"],["type Nullable<'T (requires default constructor and value type and 'T :> ValueType)> =\n  struct\n    new : value:'T -> Nullable<'T>\n    member Equals : other:obj -> bool\n    member GetHashCode : unit -> int\n    member GetValueOrDefault : unit -> 'T + 1 overload\n    member HasValue : bool\n    member ToString : unit -> string\n    member Value : 'T\n  end"],["System.Nullable ()","System.Nullable(value: 'T) : System.Nullable<'T>"]]}""" + "\n" + """{"word":"MulticastDelegate","info":[["type MulticastDelegate =\n  inherit Delegate\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member GetInvocationList : unit -> Delegate[]\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit"]]}""" + "\n" + """{"word":"ModuleHandle","info":[["type ModuleHandle =\n  struct\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetRuntimeFieldHandleFromMetadataToken : fieldToken:int -> RuntimeFieldHandle\n    member GetRuntimeMethodHandleFromMetadataToken : methodToken:int -> RuntimeMethodHandle\n    member GetRuntimeTypeHandleFromMetadataToken : typeToken:int -> RuntimeTypeHandle\n    member MDStreamVersion : int\n    member ResolveFieldHandle : fieldToken:int -> RuntimeFieldHandle + 1 overload\n    member ResolveMethodHandle : methodToken:int -> RuntimeMethodHandle + 1 overload\n    member ResolveTypeHandle : typeToken:int -> RuntimeTypeHandle + 1 overload\n    static val EmptyHandle : ModuleHandle\n  end"]]}""" + "\n" + """{"word":"MarshalByRefObject","info":[["type MarshalByRefObject =\n  member CreateObjRef : requestedType:Type -> ObjRef\n  member GetLifetimeService : unit -> obj\n  member InitializeLifetimeService : unit -> obj"]]}""" + "\n" + """{"word":"IntPtr","info":[["type IntPtr =\n  struct\n    new : value:int -> nativeint + 2 overloads\n    member Equals : obj:obj -> bool\n    member GetHashCode : unit -> int\n    member ToInt32 : unit -> int\n    member ToInt64 : unit -> int64\n    member ToPointer : unit -> unit\n    member ToString : unit -> string + 1 overload\n    static val Zero : nativeint\n    static member Add : pointer:nativeint * offset:int -> nativeint\n    static member Size : int\n    ...\n  end"],["System.IntPtr ()","System.IntPtr(value: int) : System.IntPtr","System.IntPtr(value: int64) : System.IntPtr","System.IntPtr(value: nativeptr<unit>) : System.IntPtr"]]}""" + "\n" + """{"word":"EnvironmentVariableTarget","info":[["type EnvironmentVariableTarget =\n  | Process = 0\n  | User = 1\n  | Machine = 2"]]}""" + "\n" + """{"word":"AppDomainManagerInitializationOptions","info":[["type AppDomainManagerInitializationOptions =\n  | None = 0\n  | RegisterWithHost = 1"]]}""" + "\n" + """{"word":"Delegate","info":[["type Delegate =\n  member Clone : unit -> obj\n  member DynamicInvoke : [<ParamArray>] args:obj[] -> obj\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member GetInvocationList : unit -> Delegate[]\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Method : MethodInfo\n  member Target : obj\n  static member Combine : [<ParamArray>] delegates:Delegate[] -> Delegate + 1 overload\n  static member CreateDelegate : type:Type * method:MethodInfo -> Delegate + 9 overloads\n  ..."]]}""" + "\n" + """{"word":"CrossAppDomainDelegate","info":[["type CrossAppDomainDelegate =\n  delegate of unit -> unit"]]}""" + "\n" + """{"word":"Console","info":[["type Console =\n  static member BackgroundColor : ConsoleColor with get, set\n  static member Beep : unit -> unit + 1 overload\n  static member BufferHeight : int with get, set\n  static member BufferWidth : int with get, set\n  static member CapsLock : bool\n  static member Clear : unit -> unit\n  static member CursorLeft : int with get, set\n  static member CursorSize : int with get, set\n  static member CursorTop : int with get, set\n  static member CursorVisible : bool with get, set\n  ..."]]}""" + "\n" + """{"word":"AssemblyLoadEventHandler","info":[["type AssemblyLoadEventHandler =\n  delegate of obj * AssemblyLoadEventArgs -> unit"]]}""" + "\n" + """{"word":"AssemblyLoadEventArgs","info":[["type AssemblyLoadEventArgs =\n  inherit EventArgs\n  new : loadedAssembly:Assembly -> AssemblyLoadEventArgs\n  member LoadedAssembly : Assembly"],["System.AssemblyLoadEventArgs(loadedAssembly: System.Reflection.Assembly) : System.AssemblyLoadEventArgs"]]}""" + "\n" + """{"word":"ArgIterator","info":[["type ArgIterator =\n  struct\n    new : arglist:RuntimeArgumentHandle -> ArgIterator + 1 overload\n    member End : unit -> unit\n    member Equals : o:obj -> bool\n    member GetHashCode : unit -> int\n    member GetNextArg : unit -> TypedReference + 1 overload\n    member GetNextArgType : unit -> RuntimeTypeHandle\n    member GetRemainingCount : unit -> int\n  end"],["System.ArgIterator ()","System.ArgIterator(arglist: System.RuntimeArgumentHandle) : System.ArgIterator","System.ArgIterator(arglist: System.RuntimeArgumentHandle, ptr: nativeptr<unit>) : System.ArgIterator"]]}""" + "\n" + """{"word":"ApplicationIdentity","info":[["type ApplicationIdentity =\n  new : applicationIdentityFullName:string -> ApplicationIdentity\n  member CodeBase : string\n  member FullName : string\n  member ToString : unit -> string"],["System.ApplicationIdentity(applicationIdentityFullName: string) : System.ApplicationIdentity"]]}""" + "\n" + """{"word":"AppDomainSetup","info":[["type AppDomainSetup =\n  new : unit -> AppDomainSetup + 2 overloads\n  member ActivationArguments : ActivationArguments with get, set\n  member AppDomainInitializer : AppDomainInitializer with get, set\n  member AppDomainInitializerArguments : string[] with get, set\n  member ApplicationBase : string with get, set\n  member ApplicationName : string with get, set\n  member ApplicationTrust : ApplicationTrust with get, set\n  member CachePath : string with get, set\n  member ConfigurationFile : string with get, set\n  member DisallowApplicationBaseProbing : bool with get, set\n  ..."],["System.AppDomainSetup() : System.AppDomainSetup","System.AppDomainSetup(activationArguments: System.Runtime.Hosting.ActivationArguments) : System.AppDomainSetup","System.AppDomainSetup(activationContext: System.ActivationContext) : System.AppDomainSetup"]]}""" + "\n" + """{"word":"AppDomainManager","info":[["type AppDomainManager =\n  inherit MarshalByRefObject\n  new : unit -> AppDomainManager\n  member ApplicationActivator : ApplicationActivator\n  member CheckSecuritySettings : state:SecurityState -> bool\n  member CreateDomain : friendlyName:string * securityInfo:Evidence * appDomainInfo:AppDomainSetup -> AppDomain\n  member EntryAssembly : Assembly\n  member HostExecutionContextManager : HostExecutionContextManager\n  member HostSecurityManager : HostSecurityManager\n  member InitializationFlags : AppDomainManagerInitializationOptions with get, set\n  member InitializeNewDomain : appDomainInfo:AppDomainSetup -> unit"],["System.AppDomainManager() : System.AppDomainManager"]]}""" + "\n" + """{"word":"AppDomainInitializer","info":[["type AppDomainInitializer =\n  delegate of string[] -> unit"]]}""" + "\n" + """{"word":"ActivationContext","info":[["type ActivationContext =\n  member Dispose : unit -> unit\n  member Form : ContextForm\n  member Identity : ApplicationIdentity\n  static member CreatePartialActivationContext : identity:ApplicationIdentity -> ActivationContext + 1 overload\n  nested type ContextForm"]]}""" + "\n" + """{"word":"Environment","info":[["type Environment =\n  static member CommandLine : string\n  static member CurrentDirectory : string with get, set\n  static member CurrentManagedThreadId : int\n  static member Exit : exitCode:int -> unit\n  static member ExitCode : int with get, set\n  static member ExpandEnvironmentVariables : name:string -> string\n  static member FailFast : message:string -> unit + 1 overload\n  static member GetCommandLineArgs : unit -> string[]\n  static member GetEnvironmentVariable : variable:string -> string + 1 overload\n  static member GetEnvironmentVariables : unit -> IDictionary + 1 overload\n  ...\n  nested type SpecialFolder\n  nested type SpecialFolderOption"]]}""" + "\n" + """{"word":"AppDomain","info":[["type AppDomain =\n  inherit MarshalByRefObject\n  member ActivationContext : ActivationContext\n  member AppendPrivatePath : path:string -> unit\n  member ApplicationIdentity : ApplicationIdentity\n  member ApplicationTrust : ApplicationTrust\n  member ApplyPolicy : assemblyName:string -> string\n  member BaseDirectory : string\n  member ClearPrivatePath : unit -> unit\n  member ClearShadowCopyPath : unit -> unit\n  member CreateComInstanceFrom : assemblyName:string * typeName:string -> ObjectHandle + 1 overload\n  member CreateInstance : assemblyName:string * typeName:string -> ObjectHandle + 3 overloads\n  ..."]]}""" + "\n" + """{"word":"Version","info":[["type Version =\n  new : unit -> Version + 4 overloads\n  member Build : int\n  member Clone : unit -> obj\n  member CompareTo : version:obj -> int + 1 overload\n  member Equals : obj:obj -> bool + 1 overload\n  member GetHashCode : unit -> int\n  member Major : int\n  member MajorRevision : int16\n  member Minor : int\n  member MinorRevision : int16\n  ..."],["System.Version() : System.Version","System.Version(version: string) : System.Version","System.Version(major: int, minor: int) : System.Version","System.Version(major: int, minor: int, build: int) : System.Version","System.Version(major: int, minor: int, build: int, revision: int) : System.Version"]]}""" + "\n" + """{"word":"UnhandledExceptionEventHandler","info":[["type UnhandledExceptionEventHandler =\n  delegate of obj * UnhandledExceptionEventArgs -> unit"]]}""" + "\n" + """{"word":"UnhandledExceptionEventArgs","info":[["type UnhandledExceptionEventArgs =\n  inherit EventArgs\n  new : exception:obj * isTerminating:bool -> UnhandledExceptionEventArgs\n  member ExceptionObject : obj\n  member IsTerminating : bool"],["System.UnhandledExceptionEventArgs(exception: obj, isTerminating: bool) : System.UnhandledExceptionEventArgs"]]}""" + "\n" + """{"word":"UnauthorizedAccessException","info":[["type UnauthorizedAccessException =\n  inherit SystemException\n  new : unit -> UnauthorizedAccessException + 2 overloads"],["System.UnauthorizedAccessException() : System.UnauthorizedAccessException","System.UnauthorizedAccessException(message: string) : System.UnauthorizedAccessException","System.UnauthorizedAccessException(message: string, inner: exn) : System.UnauthorizedAccessException"]]}""" + "\n" + """{"word":"UInt64","info":[["type UInt64 =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : uint64\n    static val MinValue : uint64\n    static member Parse : s:string -> uint64 + 3 overloads\n    static member TryParse : s:string * result:uint64 -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"UInt32","info":[["type UInt32 =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : uint32\n    static val MinValue : uint32\n    static member Parse : s:string -> uint32 + 3 overloads\n    static member TryParse : s:string * result:uint32 -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"UInt16","info":[["type UInt16 =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : uint16\n    static val MinValue : uint16\n    static member Parse : s:string -> uint16 + 3 overloads\n    static member TryParse : s:string * result:uint16 -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"TypeUnloadedException","info":[["type TypeUnloadedException =\n  inherit SystemException\n  new : unit -> TypeUnloadedException + 2 overloads"],["System.TypeUnloadedException() : System.TypeUnloadedException","System.TypeUnloadedException(message: string) : System.TypeUnloadedException","System.TypeUnloadedException(message: string, innerException: exn) : System.TypeUnloadedException"]]}""" + "\n" + """{"word":"TypeLoadException","info":[["type TypeLoadException =\n  inherit SystemException\n  new : unit -> TypeLoadException + 2 overloads\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Message : string\n  member TypeName : string"],["System.TypeLoadException() : System.TypeLoadException","System.TypeLoadException(message: string) : System.TypeLoadException","System.TypeLoadException(message: string, inner: exn) : System.TypeLoadException"]]}""" + "\n" + """{"word":"TypeInitializationException","info":[["type TypeInitializationException =\n  inherit SystemException\n  new : fullTypeName:string * innerException:Exception -> TypeInitializationException\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member TypeName : string"],["System.TypeInitializationException(fullTypeName: string, innerException: exn) : System.TypeInitializationException"]]}""" + "\n" + """{"word":"TypedReference","info":[["type TypedReference =\n  struct\n    member Equals : o:obj -> bool\n    member GetHashCode : unit -> int\n    static member GetTargetType : value:TypedReference -> Type\n    static member MakeTypedReference : target:obj * flds:FieldInfo[] -> TypedReference\n    static member SetTypedReference : target:TypedReference * value:obj -> unit\n    static member TargetTypeToken : value:TypedReference -> RuntimeTypeHandle\n    static member ToObject : value:TypedReference -> obj\n  end"]]}""" + "\n" + """{"word":"TypeAccessException","info":[["type TypeAccessException =\n  inherit TypeLoadException\n  new : unit -> TypeAccessException + 2 overloads"],["System.TypeAccessException() : System.TypeAccessException","System.TypeAccessException(message: string) : System.TypeAccessException","System.TypeAccessException(message: string, inner: exn) : System.TypeAccessException"]]}""" + "\n" + """{"word":"Type","info":[["type Type =\n  inherit MemberInfo\n  member Assembly : Assembly\n  member AssemblyQualifiedName : string\n  member Attributes : TypeAttributes\n  member BaseType : Type\n  member ContainsGenericParameters : bool\n  member DeclaringMethod : MethodBase\n  member DeclaringType : Type\n  member Equals : o:obj -> bool + 1 overload\n  member FindInterfaces : filter:TypeFilter * filterCriteria:obj -> Type[]\n  member FindMembers : memberType:MemberTypes * bindingAttr:BindingFlags * filter:MemberFilter * filterCriteria:obj -> MemberInfo[]\n  ..."]]}""" + "\n" + """{"word":"TimeZoneNotFoundException","info":[["type TimeZoneNotFoundException =\n  inherit Exception\n  new : unit -> TimeZoneNotFoundException + 2 overloads"],["System.TimeZoneNotFoundException() : System.TimeZoneNotFoundException","System.TimeZoneNotFoundException(message: string) : System.TimeZoneNotFoundException","System.TimeZoneNotFoundException(message: string, innerException: exn) : System.TimeZoneNotFoundException"]]}""" + "\n" + """{"word":"TimeZoneInfo","info":[["type TimeZoneInfo =\n  member BaseUtcOffset : TimeSpan\n  member DaylightName : string\n  member DisplayName : string\n  member Equals : obj:obj -> bool + 1 overload\n  member GetAdjustmentRules : unit -> AdjustmentRule[]\n  member GetAmbiguousTimeOffsets : dateTime:DateTime -> TimeSpan[] + 1 overload\n  member GetHashCode : unit -> int\n  member GetUtcOffset : dateTime:DateTime -> TimeSpan + 1 overload\n  member HasSameRules : other:TimeZoneInfo -> bool\n  member Id : string\n  ...\n  nested type AdjustmentRule\n  nested type TransitionTime"]]}""" + "\n" + """{"word":"TimeSpan","info":[["type TimeSpan =\n  struct\n    new : ticks:int64 -> TimeSpan + 3 overloads\n    member Add : ts:TimeSpan -> TimeSpan\n    member CompareTo : value:obj -> int + 1 overload\n    member Days : int\n    member Duration : unit -> TimeSpan\n    member Equals : value:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member Hours : int\n    member Milliseconds : int\n    member Minutes : int\n    ...\n  end"],["System.TimeSpan ()","System.TimeSpan(ticks: int64) : System.TimeSpan","System.TimeSpan(hours: int, minutes: int, seconds: int) : System.TimeSpan","System.TimeSpan(days: int, hours: int, minutes: int, seconds: int) : System.TimeSpan","System.TimeSpan(days: int, hours: int, minutes: int, seconds: int, milliseconds: int) : System.TimeSpan"]]}""" + "\n" + """{"word":"TimeoutException","info":[["type TimeoutException =\n  inherit SystemException\n  new : unit -> TimeoutException + 2 overloads"],["System.TimeoutException() : System.TimeoutException","System.TimeoutException(message: string) : System.TimeoutException","System.TimeoutException(message: string, innerException: exn) : System.TimeoutException"]]}""" + "\n" + """{"word":"ThreadStaticAttribute","info":[["type ThreadStaticAttribute =\n  inherit Attribute\n  new : unit -> ThreadStaticAttribute"],["System.ThreadStaticAttribute() : System.ThreadStaticAttribute"]]}""" + "\n" + """{"word":"MTAThreadAttribute","info":[["type MTAThreadAttribute =\n  inherit Attribute\n  new : unit -> MTAThreadAttribute"],["System.MTAThreadAttribute() : System.MTAThreadAttribute"]]}""" + "\n" + """{"word":"STAThreadAttribute","info":[["type STAThreadAttribute =\n  inherit Attribute\n  new : unit -> STAThreadAttribute"],["System.STAThreadAttribute() : System.STAThreadAttribute"]]}""" + "\n" + """{"word":"SystemException","info":[["type SystemException =\n  inherit Exception\n  new : unit -> SystemException + 2 overloads"],["System.SystemException() : System.SystemException","System.SystemException(message: string) : System.SystemException","System.SystemException(message: string, innerException: exn) : System.SystemException"]]}""" + "\n" + """{"word":"StringComparer","info":[["type StringComparer =\n  member Compare : x:obj * y:obj -> int + 1 overload\n  member Equals : x:obj * y:obj -> bool + 1 overload\n  member GetHashCode : obj:obj -> int + 1 overload\n  static member Create : culture:CultureInfo * ignoreCase:bool -> StringComparer\n  static member CurrentCulture : StringComparer\n  static member CurrentCultureIgnoreCase : StringComparer\n  static member InvariantCulture : StringComparer\n  static member InvariantCultureIgnoreCase : StringComparer\n  static member Ordinal : StringComparer\n  static member OrdinalIgnoreCase : StringComparer"]]}""" + "\n" + """{"word":"StringSplitOptions","info":[["type StringSplitOptions =\n  | None = 0\n  | RemoveEmptyEntries = 1"]]}""" + "\n" + """{"word":"String","info":[["type String =\n  new : value:char -> string + 7 overloads\n  member Chars : int -> char\n  member Clone : unit -> obj\n  member CompareTo : value:obj -> int + 1 overload\n  member Contains : value:string -> bool\n  member CopyTo : sourceIndex:int * destination:char[] * destinationIndex:int * count:int -> unit\n  member EndsWith : value:string -> bool + 2 overloads\n  member Equals : obj:obj -> bool + 2 overloads\n  member GetEnumerator : unit -> CharEnumerator\n  member GetHashCode : unit -> int\n  ..."],["System.String(value: nativeptr<char>) : System.String","System.String(value: nativeptr<sbyte>) : System.String","System.String(value: char []) : System.String","System.String(c: char, count: int) : System.String","System.String(value: nativeptr<char>, startIndex: int, length: int) : System.String","System.String(value: nativeptr<sbyte>, startIndex: int, length: int) : System.String","System.String(value: char [], startIndex: int, length: int) : System.String","System.String(value: nativeptr<sbyte>, startIndex: int, length: int, enc: System.Text.Encoding) : System.String"]]}""" + "\n" + """{"word":"StackOverflowException","info":[["type StackOverflowException =\n  inherit SystemException\n  new : unit -> StackOverflowException + 2 overloads"],["System.StackOverflowException() : System.StackOverflowException","System.StackOverflowException(message: string) : System.StackOverflowException","System.StackOverflowException(message: string, innerException: exn) : System.StackOverflowException"]]}""" + "\n" + """{"word":"Single","info":[["type Single =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MinValue : float32\n    static val Epsilon : float32\n    static val MaxValue : float32\n    static val PositiveInfinity : float32\n    static val NegativeInfinity : float32\n    ...\n  end"]]}""" + "\n" + """{"word":"SerializableAttribute","info":[["type SerializableAttribute =\n  inherit Attribute\n  new : unit -> SerializableAttribute"],["System.SerializableAttribute() : System.SerializableAttribute"]]}""" + "\n" + """{"word":"SByte","info":[["type SByte =\n  struct\n    member CompareTo : obj:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : sbyte\n    static val MinValue : sbyte\n    static member Parse : s:string -> sbyte + 3 overloads\n    static member TryParse : s:string * result:sbyte -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"RankException","info":[["type RankException =\n  inherit SystemException\n  new : unit -> RankException + 2 overloads"],["System.RankException() : System.RankException","System.RankException(message: string) : System.RankException","System.RankException(message: string, innerException: exn) : System.RankException"]]}""" + "\n" + """{"word":"Random","info":[["type Random =\n  new : unit -> Random + 1 overload\n  member Next : unit -> int + 2 overloads\n  member NextBytes : buffer:byte[] -> unit\n  member NextDouble : unit -> float"],["System.Random() : System.Random","System.Random(Seed: int) : System.Random"]]}""" + "\n" + """{"word":"PlatformNotSupportedException","info":[["type PlatformNotSupportedException =\n  inherit NotSupportedException\n  new : unit -> PlatformNotSupportedException + 2 overloads"],["System.PlatformNotSupportedException() : System.PlatformNotSupportedException","System.PlatformNotSupportedException(message: string) : System.PlatformNotSupportedException","System.PlatformNotSupportedException(message: string, inner: exn) : System.PlatformNotSupportedException"]]}""" + "\n" + """{"word":"ParamArrayAttribute","info":[["type ParamArrayAttribute =\n  inherit Attribute\n  new : unit -> ParamArrayAttribute"],["System.ParamArrayAttribute() : System.ParamArrayAttribute"]]}""" + "\n" + """{"word":"OverflowException","info":[["type OverflowException =\n  inherit ArithmeticException\n  new : unit -> OverflowException + 2 overloads"],["System.OverflowException() : System.OverflowException","System.OverflowException(message: string) : System.OverflowException","System.OverflowException(message: string, innerException: exn) : System.OverflowException"]]}""" + "\n" + """{"word":"OutOfMemoryException","info":[["type OutOfMemoryException =\n  inherit SystemException\n  new : unit -> OutOfMemoryException + 2 overloads"],["System.OutOfMemoryException() : System.OutOfMemoryException","System.OutOfMemoryException(message: string) : System.OutOfMemoryException","System.OutOfMemoryException(message: string, innerException: exn) : System.OutOfMemoryException"]]}""" + "\n" + """{"word":"OperationCanceledException","info":[["type OperationCanceledException =\n  inherit SystemException\n  new : unit -> OperationCanceledException + 5 overloads\n  member CancellationToken : CancellationToken with get, set"],["System.OperationCanceledException() : System.OperationCanceledException","System.OperationCanceledException(message: string) : System.OperationCanceledException","System.OperationCanceledException(token: System.Threading.CancellationToken) : System.OperationCanceledException","System.OperationCanceledException(message: string, innerException: exn) : System.OperationCanceledException","System.OperationCanceledException(message: string, token: System.Threading.CancellationToken) : System.OperationCanceledException","System.OperationCanceledException(message: string, innerException: exn, token: System.Threading.CancellationToken) : System.OperationCanceledException"]]}""" + "\n" + """{"word":"ObsoleteAttribute","info":[["type ObsoleteAttribute =\n  inherit Attribute\n  new : unit -> ObsoleteAttribute + 2 overloads\n  member IsError : bool\n  member Message : string"],["System.ObsoleteAttribute() : System.ObsoleteAttribute","System.ObsoleteAttribute(message: string) : System.ObsoleteAttribute","System.ObsoleteAttribute(message: string, error: bool) : System.ObsoleteAttribute"]]}""" + "\n" + """{"word":"ObjectDisposedException","info":[["type ObjectDisposedException =\n  inherit InvalidOperationException\n  new : objectName:string -> ObjectDisposedException + 2 overloads\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Message : string\n  member ObjectName : string"],["System.ObjectDisposedException(objectName: string) : System.ObjectDisposedException","System.ObjectDisposedException(objectName: string, message: string) : System.ObjectDisposedException","System.ObjectDisposedException(message: string, innerException: exn) : System.ObjectDisposedException"]]}""" + "\n" + """{"word":"NullReferenceException","info":[["type NullReferenceException =\n  inherit SystemException\n  new : unit -> NullReferenceException + 2 overloads"],["System.NullReferenceException() : System.NullReferenceException","System.NullReferenceException(message: string) : System.NullReferenceException","System.NullReferenceException(message: string, innerException: exn) : System.NullReferenceException"]]}""" + "\n" + """{"word":"NotSupportedException","info":[["type NotSupportedException =\n  inherit SystemException\n  new : unit -> NotSupportedException + 2 overloads"],["System.NotSupportedException() : System.NotSupportedException","System.NotSupportedException(message: string) : System.NotSupportedException","System.NotSupportedException(message: string, innerException: exn) : System.NotSupportedException"]]}""" + "\n" + """{"word":"NotImplementedException","info":[["type NotImplementedException =\n  inherit SystemException\n  new : unit -> NotImplementedException + 2 overloads"],["System.NotImplementedException() : System.NotImplementedException","System.NotImplementedException(message: string) : System.NotImplementedException","System.NotImplementedException(message: string, inner: exn) : System.NotImplementedException"]]}""" + "\n" + """{"word":"NotFiniteNumberException","info":[["type NotFiniteNumberException =\n  inherit ArithmeticException\n  new : unit -> NotFiniteNumberException + 5 overloads\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member OffendingNumber : float"],["System.NotFiniteNumberException() : System.NotFiniteNumberException","System.NotFiniteNumberException(offendingNumber: float) : System.NotFiniteNumberException","System.NotFiniteNumberException(message: string) : System.NotFiniteNumberException","System.NotFiniteNumberException(message: string, offendingNumber: float) : System.NotFiniteNumberException","System.NotFiniteNumberException(message: string, innerException: exn) : System.NotFiniteNumberException","System.NotFiniteNumberException(message: string, offendingNumber: float, innerException: exn) : System.NotFiniteNumberException"]]}""" + "\n" + """{"word":"NonSerializedAttribute","info":[["type NonSerializedAttribute =\n  inherit Attribute\n  new : unit -> NonSerializedAttribute"],["System.NonSerializedAttribute() : System.NonSerializedAttribute"]]}""" + "\n" + """{"word":"MulticastNotSupportedException","info":[["type MulticastNotSupportedException =\n  inherit SystemException\n  new : unit -> MulticastNotSupportedException + 2 overloads"],["System.MulticastNotSupportedException() : System.MulticastNotSupportedException","System.MulticastNotSupportedException(message: string) : System.MulticastNotSupportedException","System.MulticastNotSupportedException(message: string, inner: exn) : System.MulticastNotSupportedException"]]}""" + "\n" + """{"word":"MissingMethodException","info":[["type MissingMethodException =\n  inherit MissingMemberException\n  new : unit -> MissingMethodException + 3 overloads\n  member Message : string"],["System.MissingMethodException() : System.MissingMethodException","System.MissingMethodException(message: string) : System.MissingMethodException","System.MissingMethodException(message: string, inner: exn) : System.MissingMethodException","System.MissingMethodException(className: string, methodName: string) : System.MissingMethodException"]]}""" + "\n" + """{"word":"MissingMemberException","info":[["type MissingMemberException =\n  inherit MemberAccessException\n  new : unit -> MissingMemberException + 3 overloads\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Message : string"],["System.MissingMemberException() : System.MissingMemberException","System.MissingMemberException(message: string) : System.MissingMemberException","System.MissingMemberException(message: string, inner: exn) : System.MissingMemberException","System.MissingMemberException(className: string, memberName: string) : System.MissingMemberException"]]}""" + "\n" + """{"word":"MissingFieldException","info":[["type MissingFieldException =\n  inherit MissingMemberException\n  new : unit -> MissingFieldException + 3 overloads\n  member Message : string"],["System.MissingFieldException() : System.MissingFieldException","System.MissingFieldException(message: string) : System.MissingFieldException","System.MissingFieldException(message: string, inner: exn) : System.MissingFieldException","System.MissingFieldException(className: string, fieldName: string) : System.MissingFieldException"]]}""" + "\n" + """{"word":"MidpointRounding","info":[["type MidpointRounding =\n  | ToEven = 0\n  | AwayFromZero = 1"]]}""" + "\n" + """{"word":"MethodAccessException","info":[["type MethodAccessException =\n  inherit MemberAccessException\n  new : unit -> MethodAccessException + 2 overloads"],["System.MethodAccessException() : System.MethodAccessException","System.MethodAccessException(message: string) : System.MethodAccessException","System.MethodAccessException(message: string, inner: exn) : System.MethodAccessException"]]}""" + "\n" + """{"word":"MemberAccessException","info":[["type MemberAccessException =\n  inherit SystemException\n  new : unit -> MemberAccessException + 2 overloads"],["System.MemberAccessException() : System.MemberAccessException","System.MemberAccessException(message: string) : System.MemberAccessException","System.MemberAccessException(message: string, inner: exn) : System.MemberAccessException"]]}""" + "\n" + """{"word":"Math","info":[["type Math =\n  static val PI : float\n  static val E : float\n  static member Abs : value:sbyte -> sbyte + 6 overloads\n  static member Acos : d:float -> float\n  static member Asin : d:float -> float\n  static member Atan : d:float -> float\n  static member Atan2 : y:float * x:float -> float\n  static member BigMul : a:int * b:int -> int64\n  static member Ceiling : d:decimal -> decimal + 1 overload\n  static member Cos : d:float -> float\n  ..."]]}""" + "\n" + """{"word":"IServiceProvider","info":[["type IServiceProvider =\n  member GetService : serviceType:Type -> obj"]]}""" + "\n" + """{"word":"InvalidTimeZoneException","info":[["type InvalidTimeZoneException =\n  inherit Exception\n  new : unit -> InvalidTimeZoneException + 2 overloads"],["System.InvalidTimeZoneException() : System.InvalidTimeZoneException","System.InvalidTimeZoneException(message: string) : System.InvalidTimeZoneException","System.InvalidTimeZoneException(message: string, innerException: exn) : System.InvalidTimeZoneException"]]}""" + "\n" + """{"word":"InvalidProgramException","info":[["type InvalidProgramException =\n  inherit SystemException\n  new : unit -> InvalidProgramException + 2 overloads"],["System.InvalidProgramException() : System.InvalidProgramException","System.InvalidProgramException(message: string) : System.InvalidProgramException","System.InvalidProgramException(message: string, inner: exn) : System.InvalidProgramException"]]}""" + "\n" + """{"word":"InvalidOperationException","info":[["type InvalidOperationException =\n  inherit SystemException\n  new : unit -> InvalidOperationException + 2 overloads"],["System.InvalidOperationException() : System.InvalidOperationException","System.InvalidOperationException(message: string) : System.InvalidOperationException","System.InvalidOperationException(message: string, innerException: exn) : System.InvalidOperationException"]]}""" + "\n" + """{"word":"InvalidCastException","info":[["type InvalidCastException =\n  inherit SystemException\n  new : unit -> InvalidCastException + 3 overloads"],["System.InvalidCastException() : System.InvalidCastException","System.InvalidCastException(message: string) : System.InvalidCastException","System.InvalidCastException(message: string, innerException: exn) : System.InvalidCastException","System.InvalidCastException(message: string, errorCode: int) : System.InvalidCastException"]]}""" + "\n" + """{"word":"Int64","info":[["type Int64 =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : int64\n    static val MinValue : int64\n    static member Parse : s:string -> int64 + 3 overloads\n    static member TryParse : s:string * result:int64 -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"Int32","info":[["type Int32 =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : int\n    static val MinValue : int\n    static member Parse : s:string -> int + 3 overloads\n    static member TryParse : s:string * result:int -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"Int16","info":[["type Int16 =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : int16\n    static val MinValue : int16\n    static member Parse : s:string -> int16 + 3 overloads\n    static member TryParse : s:string * result:int16 -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"InsufficientMemoryException","info":[["type InsufficientMemoryException =\n  inherit OutOfMemoryException\n  new : unit -> InsufficientMemoryException + 2 overloads"],["System.InsufficientMemoryException() : System.InsufficientMemoryException","System.InsufficientMemoryException(message: string) : System.InsufficientMemoryException","System.InsufficientMemoryException(message: string, innerException: exn) : System.InsufficientMemoryException"]]}""" + "\n" + """{"word":"InsufficientExecutionStackException","info":[["type InsufficientExecutionStackException =\n  inherit SystemException\n  new : unit -> InsufficientExecutionStackException + 2 overloads"],["System.InsufficientExecutionStackException() : System.InsufficientExecutionStackException","System.InsufficientExecutionStackException(message: string) : System.InsufficientExecutionStackException","System.InsufficientExecutionStackException(message: string, innerException: exn) : System.InsufficientExecutionStackException"]]}""" + "\n" + """{"word":"IndexOutOfRangeException","info":[["type IndexOutOfRangeException =\n  inherit SystemException\n  new : unit -> IndexOutOfRangeException + 2 overloads"],["System.IndexOutOfRangeException() : System.IndexOutOfRangeException","System.IndexOutOfRangeException(message: string) : System.IndexOutOfRangeException","System.IndexOutOfRangeException(message: string, innerException: exn) : System.IndexOutOfRangeException"]]}""" + "\n" + """{"word":"IFormattable","info":[["type IFormattable =\n  member ToString : format:string * formatProvider:IFormatProvider -> string"]]}""" + "\n" + """{"word":"IFormatProvider","info":[["type IFormatProvider =\n  member GetFormat : formatType:Type -> obj"]]}""" + "\n" + """{"word":"IDisposable","info":[["type IDisposable =\n  member Dispose : unit -> unit"]]}""" + "\n" + """{"word":"ICustomFormatter","info":[["type ICustomFormatter =\n  member Format : format:string * arg:obj * formatProvider:IFormatProvider -> string"]]}""" + "\n" + """{"word":"IConvertible","info":[["type IConvertible =\n  member GetTypeCode : unit -> TypeCode\n  member ToBoolean : provider:IFormatProvider -> bool\n  member ToByte : provider:IFormatProvider -> byte\n  member ToChar : provider:IFormatProvider -> char\n  member ToDateTime : provider:IFormatProvider -> DateTime\n  member ToDecimal : provider:IFormatProvider -> decimal\n  member ToDouble : provider:IFormatProvider -> float\n  member ToInt16 : provider:IFormatProvider -> int16\n  member ToInt32 : provider:IFormatProvider -> int\n  member ToInt64 : provider:IFormatProvider -> int64\n  ..."]]}""" + "\n" + """{"word":"IComparable","info":[["type IComparable =\n  member CompareTo : obj:obj -> int"],["type IComparable<'T> =\n  member CompareTo : other:'T -> int"]]}""" + "\n" + """{"word":"ICloneable","info":[["type ICloneable =\n  member Clone : unit -> obj"]]}""" + "\n" + """{"word":"IAsyncResult","info":[["type IAsyncResult =\n  member AsyncState : obj\n  member AsyncWaitHandle : WaitHandle\n  member CompletedSynchronously : bool\n  member IsCompleted : bool"]]}""" + "\n" + """{"word":"IAppDomainSetup","info":[["type IAppDomainSetup =\n  member ApplicationBase : string with get, set\n  member ApplicationName : string with get, set\n  member CachePath : string with get, set\n  member ConfigurationFile : string with get, set\n  member DynamicBase : string with get, set\n  member LicenseFile : string with get, set\n  member PrivateBinPath : string with get, set\n  member PrivateBinPathProbe : string with get, set\n  member ShadowCopyDirectories : string with get, set\n  member ShadowCopyFiles : string with get, set"]]}""" + "\n" + """{"word":"_AppDomain","info":[["type _AppDomain =\n  member AppendPrivatePath : path:string -> unit\n  member BaseDirectory : string\n  member ClearPrivatePath : unit -> unit\n  member ClearShadowCopyPath : unit -> unit\n  member CreateInstance : assemblyName:string * typeName:string -> ObjectHandle + 2 overloads\n  member CreateInstanceFrom : assemblyFile:string * typeName:string -> ObjectHandle + 2 overloads\n  member DefineDynamicAssembly : name:AssemblyName * access:AssemblyBuilderAccess -> AssemblyBuilder + 8 overloads\n  member DoCallBack : theDelegate:CrossAppDomainDelegate -> unit\n  member DynamicDirectory : string\n  member Equals : other:obj -> bool\n  ..."]]}""" + "\n" + """{"word":"Guid","info":[["type Guid =\n  struct\n    new : b:byte[] -> Guid + 4 overloads\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : o:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member ToByteArray : unit -> byte[]\n    member ToString : unit -> string + 2 overloads\n    static val Empty : Guid\n    static member NewGuid : unit -> Guid\n    static member Parse : input:string -> Guid\n    static member ParseExact : input:string * format:string -> Guid\n    ...\n  end"],["System.Guid ()","System.Guid(b: byte []) : System.Guid","System.Guid(g: string) : System.Guid","System.Guid(a: int, b: int16, c: int16, d: byte []) : System.Guid","System.Guid(a: uint32, b: uint16, c: uint16, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte) : System.Guid","System.Guid(a: int, b: int16, c: int16, d: byte, e: byte, f: byte, g: byte, h: byte, i: byte, j: byte, k: byte) : System.Guid"]]}""" + "\n" + """{"word":"GC","info":[["type GC =\n  static member AddMemoryPressure : bytesAllocated:int64 -> unit\n  static member CancelFullGCNotification : unit -> unit\n  static member Collect : unit -> unit + 4 overloads\n  static member CollectionCount : generation:int -> int\n  static member EndNoGCRegion : unit -> unit\n  static member GetGeneration : obj:obj -> int + 1 overload\n  static member GetTotalMemory : forceFullCollection:bool -> int64\n  static member KeepAlive : obj:obj -> unit\n  static member MaxGeneration : int\n  static member ReRegisterForFinalize : obj:obj -> unit\n  ..."]]}""" + "\n" + """{"word":"GCNotificationStatus","info":[["type GCNotificationStatus =\n  | Succeeded = 0\n  | Failed = 1\n  | Canceled = 2\n  | Timeout = 3\n  | NotApplicable = 4"]]}""" + "\n" + """{"word":"GCCollectionMode","info":[["type GCCollectionMode =\n  | Default = 0\n  | Forced = 1\n  | Optimized = 2"]]}""" + "\n" + """{"word":"FormatException","info":[["type FormatException =\n  inherit SystemException\n  new : unit -> FormatException + 2 overloads"],["System.FormatException() : System.FormatException","System.FormatException(message: string) : System.FormatException","System.FormatException(message: string, innerException: exn) : System.FormatException"]]}""" + "\n" + """{"word":"FlagsAttribute","info":[["type FlagsAttribute =\n  inherit Attribute\n  new : unit -> FlagsAttribute"],["System.FlagsAttribute() : System.FlagsAttribute"]]}""" + "\n" + """{"word":"FieldAccessException","info":[["type FieldAccessException =\n  inherit MemberAccessException\n  new : unit -> FieldAccessException + 2 overloads"],["System.FieldAccessException() : System.FieldAccessException","System.FieldAccessException(message: string) : System.FieldAccessException","System.FieldAccessException(message: string, inner: exn) : System.FieldAccessException"]]}""" + "\n" + """{"word":"Exception","info":[["type Exception =\n  new : unit -> Exception + 2 overloads\n  member Data : IDictionary\n  member GetBaseException : unit -> Exception\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member GetType : unit -> Type\n  member HResult : int with get, set\n  member HelpLink : string with get, set\n  member InnerException : Exception\n  member Message : string\n  member Source : string with get, set\n  ..."],["System.Exception() : System.Exception","System.Exception(message: string) : System.Exception","System.Exception(message: string, innerException: exn) : System.Exception"]]}""" + "\n" + """{"word":"EventHandler","info":[["type EventHandler =\n  delegate of obj * EventArgs -> unit"],["type EventHandler<'TEventArgs> =\n  delegate of obj * 'TEventArgs -> unit"]]}""" + "\n" + """{"word":"EventArgs","info":[["type EventArgs =\n  new : unit -> EventArgs\n  static val Empty : EventArgs"],["System.EventArgs() : System.EventArgs"]]}""" + "\n" + """{"word":"Enum","info":[["type Enum =\n  member CompareTo : target:obj -> int\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member GetTypeCode : unit -> TypeCode\n  member HasFlag : flag:Enum -> bool\n  member ToString : unit -> string + 3 overloads\n  static member Format : enumType:Type * value:obj * format:string -> string\n  static member GetName : enumType:Type * value:obj -> string\n  static member GetNames : enumType:Type -> string[]\n  static member GetUnderlyingType : enumType:Type -> Type\n  ..."]]}""" + "\n" + """{"word":"EntryPointNotFoundException","info":[["type EntryPointNotFoundException =\n  inherit TypeLoadException\n  new : unit -> EntryPointNotFoundException + 2 overloads"],["System.EntryPointNotFoundException() : System.EntryPointNotFoundException","System.EntryPointNotFoundException(message: string) : System.EntryPointNotFoundException","System.EntryPointNotFoundException(message: string, inner: exn) : System.EntryPointNotFoundException"]]}""" + "\n" + """{"word":"DuplicateWaitObjectException","info":[["type DuplicateWaitObjectException =\n  inherit ArgumentException\n  new : unit -> DuplicateWaitObjectException + 3 overloads"],["System.DuplicateWaitObjectException() : System.DuplicateWaitObjectException","System.DuplicateWaitObjectException(parameterName: string) : System.DuplicateWaitObjectException","System.DuplicateWaitObjectException(parameterName: string, message: string) : System.DuplicateWaitObjectException","System.DuplicateWaitObjectException(message: string, innerException: exn) : System.DuplicateWaitObjectException"]]}""" + "\n" + """{"word":"Double","info":[["type Double =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MinValue : float\n    static val MaxValue : float\n    static val Epsilon : float\n    static val NegativeInfinity : float\n    static val PositiveInfinity : float\n    ...\n  end"]]}""" + "\n" + """{"word":"DllNotFoundException","info":[["type DllNotFoundException =\n  inherit TypeLoadException\n  new : unit -> DllNotFoundException + 2 overloads"],["System.DllNotFoundException() : System.DllNotFoundException","System.DllNotFoundException(message: string) : System.DllNotFoundException","System.DllNotFoundException(message: string, inner: exn) : System.DllNotFoundException"]]}""" + "\n" + """{"word":"DivideByZeroException","info":[["type DivideByZeroException =\n  inherit ArithmeticException\n  new : unit -> DivideByZeroException + 2 overloads"],["System.DivideByZeroException() : System.DivideByZeroException","System.DivideByZeroException(message: string) : System.DivideByZeroException","System.DivideByZeroException(message: string, innerException: exn) : System.DivideByZeroException"]]}""" + "\n" + """{"word":"Decimal","info":[["type Decimal =\n  struct\n    new : value:int -> decimal + 7 overloads\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : value:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val Zero : decimal\n    static val One : decimal\n    static val MinusOne : decimal\n    static val MaxValue : decimal\n    ...\n  end"],["System.Decimal ()","System.Decimal(value: int) : System.Decimal","System.Decimal(value: uint32) : System.Decimal","System.Decimal(value: int64) : System.Decimal","System.Decimal(value: uint64) : System.Decimal","System.Decimal(value: float32) : System.Decimal","System.Decimal(value: float) : System.Decimal","System.Decimal(bits: int []) : System.Decimal","System.Decimal(lo: int, mid: int, hi: int, isNegative: bool, scale: byte) : System.Decimal"]]}""" + "\n" + """{"word":"DBNull","info":[["type DBNull =\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member GetTypeCode : unit -> TypeCode\n  member ToString : unit -> string + 1 overload\n  static val Value : DBNull"]]}""" + "\n" + """{"word":"DayOfWeek","info":[["type DayOfWeek =\n  | Sunday = 0\n  | Monday = 1\n  | Tuesday = 2\n  | Wednesday = 3\n  | Thursday = 4\n  | Friday = 5\n  | Saturday = 6"]]}""" + "\n" + """{"word":"DateTimeOffset","info":[["type DateTimeOffset =\n  struct\n    new : dateTime:DateTime -> DateTimeOffset + 5 overloads\n    member Add : timeSpan:TimeSpan -> DateTimeOffset\n    member AddDays : days:float -> DateTimeOffset\n    member AddHours : hours:float -> DateTimeOffset\n    member AddMilliseconds : milliseconds:float -> DateTimeOffset\n    member AddMinutes : minutes:float -> DateTimeOffset\n    member AddMonths : months:int -> DateTimeOffset\n    member AddSeconds : seconds:float -> DateTimeOffset\n    member AddTicks : ticks:int64 -> DateTimeOffset\n    member AddYears : years:int -> DateTimeOffset\n    ...\n  end"],["System.DateTimeOffset ()","System.DateTimeOffset(dateTime: System.DateTime) : System.DateTimeOffset","System.DateTimeOffset(ticks: int64, offset: System.TimeSpan) : System.DateTimeOffset","System.DateTimeOffset(dateTime: System.DateTime, offset: System.TimeSpan) : System.DateTimeOffset","System.DateTimeOffset(year: int, month: int, day: int, hour: int, minute: int, second: int, offset: System.TimeSpan) : System.DateTimeOffset","System.DateTimeOffset(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, offset: System.TimeSpan) : System.DateTimeOffset","System.DateTimeOffset(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: System.Globalization.Calendar, offset: System.TimeSpan) : System.DateTimeOffset"]]}""" + "\n" + """{"word":"DateTimeKind","info":[["type DateTimeKind =\n  | Unspecified = 0\n  | Utc = 1\n  | Local = 2"]]}""" + "\n" + """{"word":"DateTime","info":[["type DateTime =\n  struct\n    new : ticks:int64 -> DateTime + 10 overloads\n    member Add : value:TimeSpan -> DateTime\n    member AddDays : value:float -> DateTime\n    member AddHours : value:float -> DateTime\n    member AddMilliseconds : value:float -> DateTime\n    member AddMinutes : value:float -> DateTime\n    member AddMonths : months:int -> DateTime\n    member AddSeconds : value:float -> DateTime\n    member AddTicks : value:int64 -> DateTime\n    member AddYears : value:int -> DateTime\n    ...\n  end"],["System.DateTime ()","System.DateTime(ticks: int64) : System.DateTime","System.DateTime(ticks: int64, kind: System.DateTimeKind) : System.DateTime","System.DateTime(year: int, month: int, day: int) : System.DateTime","System.DateTime(year: int, month: int, day: int, calendar: System.Globalization.Calendar) : System.DateTime","System.DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int) : System.DateTime","System.DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, kind: System.DateTimeKind) : System.DateTime","System.DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, calendar: System.Globalization.Calendar) : System.DateTime","System.DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int) : System.DateTime","System.DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, kind: System.DateTimeKind) : System.DateTime","System.DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: System.Globalization.Calendar) : System.DateTime","System.DateTime(year: int, month: int, day: int, hour: int, minute: int, second: int, millisecond: int, calendar: System.Globalization.Calendar, kind: System.DateTimeKind) : System.DateTime"]]}""" + "\n" + """{"word":"DataMisalignedException","info":[["type DataMisalignedException =\n  inherit SystemException\n  new : unit -> DataMisalignedException + 2 overloads"],["System.DataMisalignedException() : System.DataMisalignedException","System.DataMisalignedException(message: string) : System.DataMisalignedException","System.DataMisalignedException(message: string, innerException: exn) : System.DataMisalignedException"]]}""" + "\n" + """{"word":"Convert","info":[["type Convert =\n  static val DBNull : obj\n  static member ChangeType : value:obj * typeCode:TypeCode -> obj + 3 overloads\n  static member FromBase64CharArray : inArray:char[] * offset:int * length:int -> byte[]\n  static member FromBase64String : s:string -> byte[]\n  static member GetTypeCode : value:obj -> TypeCode\n  static member IsDBNull : value:obj -> bool\n  static member ToBase64CharArray : inArray:byte[] * offsetIn:int * length:int * outArray:char[] * offsetOut:int -> int + 1 overload\n  static member ToBase64String : inArray:byte[] -> string + 3 overloads\n  static member ToBoolean : value:obj -> bool + 17 overloads\n  static member ToByte : value:obj -> byte + 18 overloads\n  ..."]]}""" + "\n" + """{"word":"Base64FormattingOptions","info":[["type Base64FormattingOptions =\n  | None = 0\n  | InsertLineBreaks = 1"]]}""" + "\n" + """{"word":"ContextStaticAttribute","info":[["type ContextStaticAttribute =\n  inherit Attribute\n  new : unit -> ContextStaticAttribute"],["System.ContextStaticAttribute() : System.ContextStaticAttribute"]]}""" + "\n" + """{"word":"ContextMarshalException","info":[["type ContextMarshalException =\n  inherit SystemException\n  new : unit -> ContextMarshalException + 2 overloads"],["System.ContextMarshalException() : System.ContextMarshalException","System.ContextMarshalException(message: string) : System.ContextMarshalException","System.ContextMarshalException(message: string, inner: exn) : System.ContextMarshalException"]]}""" + "\n" + """{"word":"ContextBoundObject","info":[["type ContextBoundObject =\n  inherit MarshalByRefObject"]]}""" + "\n" + """{"word":"ConsoleSpecialKey","info":[["type ConsoleSpecialKey =\n  | ControlC = 0\n  | ControlBreak = 1"]]}""" + "\n" + """{"word":"ConsoleModifiers","info":[["type ConsoleModifiers =\n  | Alt = 1\n  | Shift = 2\n  | Control = 4"]]}""" + "\n" + """{"word":"ConsoleKeyInfo","info":[["type ConsoleKeyInfo =\n  struct\n    new : keyChar:char * key:ConsoleKey * shift:bool * alt:bool * control:bool -> ConsoleKeyInfo\n    member Equals : value:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member Key : ConsoleKey\n    member KeyChar : char\n    member Modifiers : ConsoleModifiers\n  end"],["System.ConsoleKeyInfo ()","System.ConsoleKeyInfo(keyChar: char, key: System.ConsoleKey, shift: bool, alt: bool, control: bool) : System.ConsoleKeyInfo"]]}""" + "\n" + """{"word":"ConsoleKey","info":[["type ConsoleKey =\n  | Backspace = 8\n  | Tab = 9\n  | Clear = 12\n  | Enter = 13\n  | Pause = 19\n  | Escape = 27\n  | Spacebar = 32\n  | PageUp = 33\n  | PageDown = 34\n  | End = 35\n  ..."]]}""" + "\n" + """{"word":"ConsoleColor","info":[["type ConsoleColor =\n  | Black = 0\n  | DarkBlue = 1\n  | DarkGreen = 2\n  | DarkCyan = 3\n  | DarkRed = 4\n  | DarkMagenta = 5\n  | DarkYellow = 6\n  | Gray = 7\n  | DarkGray = 8\n  | Blue = 9\n  ..."]]}""" + "\n" + """{"word":"ConsoleCancelEventArgs","info":[["type ConsoleCancelEventArgs =\n  inherit EventArgs\n  member Cancel : bool with get, set\n  member SpecialKey : ConsoleSpecialKey"]]}""" + "\n" + """{"word":"ConsoleCancelEventHandler","info":[["type ConsoleCancelEventHandler =\n  delegate of obj * ConsoleCancelEventArgs -> unit"]]}""" + "\n" + """{"word":"CLSCompliantAttribute","info":[["type CLSCompliantAttribute =\n  inherit Attribute\n  new : isCompliant:bool -> CLSCompliantAttribute\n  member IsCompliant : bool"],["System.CLSCompliantAttribute(isCompliant: bool) : System.CLSCompliantAttribute"]]}""" + "\n" + """{"word":"CharEnumerator","info":[["type CharEnumerator =\n  member Clone : unit -> obj\n  member Current : char\n  member Dispose : unit -> unit\n  member MoveNext : unit -> bool\n  member Reset : unit -> unit"]]}""" + "\n" + """{"word":"Char","info":[["type Char =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 1 overload\n    static val MaxValue : char\n    static val MinValue : char\n    static member ConvertFromUtf32 : utf32:int -> string\n    static member ConvertToUtf32 : highSurrogate:char * lowSurrogate:char -> int + 1 overload\n    static member GetNumericValue : c:char -> float + 1 overload\n    ...\n  end"]]}""" + "\n" + """{"word":"CannotUnloadAppDomainException","info":[["type CannotUnloadAppDomainException =\n  inherit SystemException\n  new : unit -> CannotUnloadAppDomainException + 2 overloads"],["System.CannotUnloadAppDomainException() : System.CannotUnloadAppDomainException","System.CannotUnloadAppDomainException(message: string) : System.CannotUnloadAppDomainException","System.CannotUnloadAppDomainException(message: string, innerException: exn) : System.CannotUnloadAppDomainException"]]}""" + "\n" + """{"word":"Byte","info":[["type Byte =\n  struct\n    member CompareTo : value:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 3 overloads\n    static val MaxValue : byte\n    static val MinValue : byte\n    static member Parse : s:string -> byte + 3 overloads\n    static member TryParse : s:string * result:byte -> bool + 1 overload\n  end"]]}""" + "\n" + """{"word":"Buffer","info":[["type Buffer =\n  static member BlockCopy : src:Array * srcOffset:int * dst:Array * dstOffset:int * count:int -> unit\n  static member ByteLength : array:Array -> int\n  static member GetByte : array:Array * index:int -> byte\n  static member MemoryCopy : source:unit * destination:unit * destinationSizeInBytes:int64 * sourceBytesToCopy:int64 -> unit + 1 overload\n  static member SetByte : array:Array * index:int * value:byte -> unit"]]}""" + "\n" + """{"word":"Boolean","info":[["type Boolean =\n  struct\n    member CompareTo : obj:obj -> int + 1 overload\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member GetTypeCode : unit -> TypeCode\n    member ToString : unit -> string + 1 overload\n    static val TrueString : string\n    static val FalseString : string\n    static member Parse : value:string -> bool\n    static member TryParse : value:string * result:bool -> bool\n  end"]]}""" + "\n" + """{"word":"BitConverter","info":[["type BitConverter =\n  static val IsLittleEndian : bool\n  static member DoubleToInt64Bits : value:float -> int64\n  static member GetBytes : value:bool -> byte[] + 9 overloads\n  static member Int64BitsToDouble : value:int64 -> float\n  static member ToBoolean : value:byte[] * startIndex:int -> bool\n  static member ToChar : value:byte[] * startIndex:int -> char\n  static member ToDouble : value:byte[] * startIndex:int -> float\n  static member ToInt16 : value:byte[] * startIndex:int -> int16\n  static member ToInt32 : value:byte[] * startIndex:int -> int\n  static member ToInt64 : value:byte[] * startIndex:int -> int64\n  ..."]]}""" + "\n" + """{"word":"BadImageFormatException","info":[["type BadImageFormatException =\n  inherit SystemException\n  new : unit -> BadImageFormatException + 4 overloads\n  member FileName : string\n  member FusionLog : string\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Message : string\n  member ToString : unit -> string"],["System.BadImageFormatException() : System.BadImageFormatException","System.BadImageFormatException(message: string) : System.BadImageFormatException","System.BadImageFormatException(message: string, inner: exn) : System.BadImageFormatException","System.BadImageFormatException(message: string, fileName: string) : System.BadImageFormatException","System.BadImageFormatException(message: string, fileName: string, inner: exn) : System.BadImageFormatException"]]}""" + "\n" + """{"word":"AttributeUsageAttribute","info":[["type AttributeUsageAttribute =\n  inherit Attribute\n  new : validOn:AttributeTargets -> AttributeUsageAttribute\n  member AllowMultiple : bool with get, set\n  member Inherited : bool with get, set\n  member ValidOn : AttributeTargets"],["System.AttributeUsageAttribute(validOn: System.AttributeTargets) : System.AttributeUsageAttribute"]]}""" + "\n" + """{"word":"AttributeTargets","info":[["type AttributeTargets =\n  | Assembly = 1\n  | Module = 2\n  | Class = 4\n  | Struct = 8\n  | Enum = 16\n  | Constructor = 32\n  | Method = 64\n  | Property = 128\n  | Field = 256\n  | Event = 512\n  ..."]]}""" + "\n" + """{"word":"Attribute","info":[["type Attribute =\n  member Equals : obj:obj -> bool\n  member GetHashCode : unit -> int\n  member IsDefaultAttribute : unit -> bool\n  member Match : obj:obj -> bool\n  member TypeId : obj\n  static member GetCustomAttribute : element:MemberInfo * attributeType:Type -> Attribute + 7 overloads\n  static member GetCustomAttributes : element:MemberInfo -> Attribute[] + 15 overloads\n  static member IsDefined : element:MemberInfo * attributeType:Type -> bool + 7 overloads"]]}""" + "\n" + """{"word":"AsyncCallback","info":[["type AsyncCallback =\n  delegate of IAsyncResult -> unit"]]}""" + "\n" + """{"word":"ArrayTypeMismatchException","info":[["type ArrayTypeMismatchException =\n  inherit SystemException\n  new : unit -> ArrayTypeMismatchException + 2 overloads"],["System.ArrayTypeMismatchException() : System.ArrayTypeMismatchException","System.ArrayTypeMismatchException(message: string) : System.ArrayTypeMismatchException","System.ArrayTypeMismatchException(message: string, innerException: exn) : System.ArrayTypeMismatchException"]]}""" + "\n" + """{"word":"ArithmeticException","info":[["type ArithmeticException =\n  inherit SystemException\n  new : unit -> ArithmeticException + 2 overloads"],["System.ArithmeticException() : System.ArithmeticException","System.ArithmeticException(message: string) : System.ArithmeticException","System.ArithmeticException(message: string, innerException: exn) : System.ArithmeticException"]]}""" + "\n" + """{"word":"ArgumentOutOfRangeException","info":[["type ArgumentOutOfRangeException =\n  inherit ArgumentException\n  new : unit -> ArgumentOutOfRangeException + 4 overloads\n  member ActualValue : obj\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Message : string"],["System.ArgumentOutOfRangeException() : System.ArgumentOutOfRangeException","System.ArgumentOutOfRangeException(paramName: string) : System.ArgumentOutOfRangeException","System.ArgumentOutOfRangeException(paramName: string, message: string) : System.ArgumentOutOfRangeException","System.ArgumentOutOfRangeException(message: string, innerException: exn) : System.ArgumentOutOfRangeException","System.ArgumentOutOfRangeException(paramName: string, actualValue: obj, message: string) : System.ArgumentOutOfRangeException"]]}""" + "\n" + """{"word":"ArgumentNullException","info":[["type ArgumentNullException =\n  inherit ArgumentException\n  new : unit -> ArgumentNullException + 3 overloads"],["System.ArgumentNullException() : System.ArgumentNullException","System.ArgumentNullException(paramName: string) : System.ArgumentNullException","System.ArgumentNullException(message: string, innerException: exn) : System.ArgumentNullException","System.ArgumentNullException(paramName: string, message: string) : System.ArgumentNullException"]]}""" + "\n" + """{"word":"ArgumentException","info":[["type ArgumentException =\n  inherit SystemException\n  new : unit -> ArgumentException + 4 overloads\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Message : string\n  member ParamName : string"],["System.ArgumentException() : System.ArgumentException","System.ArgumentException(message: string) : System.ArgumentException","System.ArgumentException(message: string, innerException: exn) : System.ArgumentException","System.ArgumentException(message: string, paramName: string) : System.ArgumentException","System.ArgumentException(message: string, paramName: string, innerException: exn) : System.ArgumentException"]]}""" + "\n" + """{"word":"ApplicationId","info":[["type ApplicationId =\n  new : publicKeyToken:byte[] * name:string * version:Version * processorArchitecture:string * culture:string -> ApplicationId\n  member Copy : unit -> ApplicationId\n  member Culture : string\n  member Equals : o:obj -> bool\n  member GetHashCode : unit -> int\n  member Name : string\n  member ProcessorArchitecture : string\n  member PublicKeyToken : byte[]\n  member ToString : unit -> string\n  member Version : Version"],["System.ApplicationId(publicKeyToken: byte [], name: string, version: System.Version, processorArchitecture: string, culture: string) : System.ApplicationId"]]}""" + "\n" + """{"word":"ApplicationException","info":[["type ApplicationException =\n  inherit Exception\n  new : unit -> ApplicationException + 2 overloads"],["System.ApplicationException() : System.ApplicationException","System.ApplicationException(message: string) : System.ApplicationException","System.ApplicationException(message: string, innerException: exn) : System.ApplicationException"]]}""" + "\n" + """{"word":"AppDomainUnloadedException","info":[["type AppDomainUnloadedException =\n  inherit SystemException\n  new : unit -> AppDomainUnloadedException + 2 overloads"],["System.AppDomainUnloadedException() : System.AppDomainUnloadedException","System.AppDomainUnloadedException(message: string) : System.AppDomainUnloadedException","System.AppDomainUnloadedException(message: string, innerException: exn) : System.AppDomainUnloadedException"]]}""" + "\n" + """{"word":"LoaderOptimizationAttribute","info":[["type LoaderOptimizationAttribute =\n  inherit Attribute\n  new : value:byte -> LoaderOptimizationAttribute + 1 overload\n  member Value : LoaderOptimization"],["System.LoaderOptimizationAttribute(value: byte) : System.LoaderOptimizationAttribute","System.LoaderOptimizationAttribute(value: System.LoaderOptimization) : System.LoaderOptimizationAttribute"]]}""" + "\n" + """{"word":"LoaderOptimization","info":[["type LoaderOptimization =\n  | NotSpecified = 0\n  | SingleDomain = 1\n  | MultiDomain = 2\n  | MultiDomainHost = 3\n  | DomainMask = 3\n  | DisallowBindings = 4"]]}""" + "\n" + """{"word":"Activator","info":[["type Activator =\n  static member CreateComInstanceFrom : assemblyName:string * typeName:string -> ObjectHandle + 1 overload\n  static member CreateInstance<'T> : unit -> 'T + 13 overloads\n  static member CreateInstanceFrom : assemblyFile:string * typeName:string -> ObjectHandle + 6 overloads\n  static member GetObject : type:Type * url:string -> obj + 1 overload"]]}""" + "\n" + """{"word":"Action","info":[["type Action =\n  delegate of unit -> unit"],["type Action<'T> =\n  delegate of 'T -> unit"],["type Action<'T1,'T2> =\n  delegate of 'T1 * 'T2 -> unit"],["type Action<'T1,'T2,'T3> =\n  delegate of 'T1 * 'T2 * 'T3 -> unit"],["type Action<'T1,'T2,'T3,'T4> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13,'T14> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 * 'T14 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13,'T14,'T15> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 * 'T14 * 'T15 -> unit"],["type Action<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13,'T14,'T15,'T16> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 * 'T14 * 'T15 * 'T16 -> unit"]]}""" + "\n" + """{"word":"AccessViolationException","info":[["type AccessViolationException =\n  inherit SystemException\n  new : unit -> AccessViolationException + 2 overloads"],["System.AccessViolationException() : System.AccessViolationException","System.AccessViolationException(message: string) : System.AccessViolationException","System.AccessViolationException(message: string, innerException: exn) : System.AccessViolationException"]]}""" + "\n" + """{"word":"LocalDataStoreSlot","info":[["type LocalDataStoreSlot ="]]}""" + "\n" + """{"word":"FormattableString","info":[["type FormattableString =\n  member ArgumentCount : int\n  member Format : string\n  member GetArgument : index:int -> obj\n  member GetArguments : unit -> obj[]\n  member ToString : unit -> string + 1 overload\n  static member Invariant : formattable:FormattableString -> string"]]}""" + "\n" + """{"word":"AppContext","info":[["type AppContext =\n  static member BaseDirectory : string\n  static member GetData : name:string -> obj\n  static member SetSwitch : switchName:string * isEnabled:bool -> unit\n  static member TargetFrameworkName : string\n  static member TryGetSwitch : switchName:string * isEnabled:bool -> bool"]]}""" + "\n" + """{"word":"AggregateException","info":[["type AggregateException =\n  inherit Exception\n  new : unit -> AggregateException + 6 overloads\n  member Flatten : unit -> AggregateException\n  member GetBaseException : unit -> Exception\n  member GetObjectData : info:SerializationInfo * context:StreamingContext -> unit\n  member Handle : predicate:Func<Exception, bool> -> unit\n  member InnerExceptions : ReadOnlyCollection<Exception>\n  member ToString : unit -> string"],["System.AggregateException() : System.AggregateException","System.AggregateException(message: string) : System.AggregateException","System.AggregateException(innerExceptions: System.Collections.Generic.IEnumerable<exn>) : System.AggregateException","System.AggregateException([<System.ParamArray>] innerExceptions: exn []) : System.AggregateException","System.AggregateException(message: string, innerException: exn) : System.AggregateException","System.AggregateException(message: string, innerExceptions: System.Collections.Generic.IEnumerable<exn>) : System.AggregateException","System.AggregateException(message: string, [<System.ParamArray>] innerExceptions: exn []) : System.AggregateException"]]}""" + "\n" + """{"word":"Array","info":[["type Array =\n  member Clone : unit -> obj\n  member CopyTo : array:Array * index:int -> unit + 1 overload\n  member GetEnumerator : unit -> IEnumerator\n  member GetLength : dimension:int -> int\n  member GetLongLength : dimension:int -> int64\n  member GetLowerBound : dimension:int -> int\n  member GetUpperBound : dimension:int -> int\n  member GetValue : index:int64 -> obj + 7 overloads\n  member Initialize : unit -> unit\n  member IsFixedSize : bool\n  ..."]]}""" + "\n" + """{"word":"TupleExtensions","info":[["type TupleExtensions =\n  static member Deconstruct<'T1> : value:Tuple<'T1> * item1:'T1 -> unit + 20 overloads\n  static member ToTuple<'T1> : value:ValueTuple<'T1> -> Tuple<'T1> + 20 overloads\n  static member ToValueTuple<'T1> : value:Tuple<'T1> -> ValueTuple<'T1> + 20 overloads"]]}""" + "\n" + """{"word":"Progress","info":[["type Progress<'T> =\n  new : unit -> Progress<'T> + 1 overload\n  event ProgressChanged : EventHandler<'T>"],["System.Progress() : System.Progress<'T>","System.Progress(handler: System.Action<'T>) : System.Progress<'T>"]]}""" + "\n" + """{"word":"IProgress","info":[["type IProgress<'T> =\n  member Report : value:'T -> unit"]]}""" + "\n" + """{"word":"IObserver","info":[["type IObserver<'T> =\n  member OnCompleted : unit -> unit\n  member OnError : error:Exception -> unit\n  member OnNext : value:'T -> unit"]]}""" + "\n" + """{"word":"IObservable","info":[["type IObservable<'T> =\n  member Subscribe : observer:IObserver<'T> -> IDisposable"]]}""" + "\n" + """{"word":"IEquatable","info":[["type IEquatable<'T> =\n  member Equals : other:'T -> bool"]]}""" + "\n" + """{"word":"ArraySegment","info":[["type ArraySegment<'T> =\n  struct\n    new : array:'T[] -> ArraySegment<'T> + 1 overload\n    member Array : 'T[]\n    member Count : int\n    member Equals : obj:obj -> bool + 1 overload\n    member GetHashCode : unit -> int\n    member Offset : int\n  end"],["System.ArraySegment ()","System.ArraySegment(array: 'T []) : System.ArraySegment<'T>","System.ArraySegment(array: 'T [], offset: int, count: int) : System.ArraySegment<'T>"]]}""" + "\n" + """{"word":"Predicate","info":[["type Predicate<'T> =\n  delegate of 'T -> bool"]]}""" + "\n" + """{"word":"Comparison","info":[["type Comparison<'T> =\n  delegate of 'T * 'T -> int"]]}""" + "\n" + """{"word":"Func","info":[["type Func<'TResult> =\n  delegate of unit -> 'TResult"],["type Func<'T,'TResult> =\n  delegate of 'T -> 'TResult"],["type Func<'T1,'T2,'TResult> =\n  delegate of 'T1 * 'T2 -> 'TResult"],["type Func<'T1,'T2,'T3,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13,'T14,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 * 'T14 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13,'T14,'T15,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 * 'T14 * 'T15 -> 'TResult"],["type Func<'T1,'T2,'T3,'T4,'T5,'T6,'T7,'T8,'T9,'T10,'T11,'T12,'T13,'T14,'T15,'T16,'TResult> =\n  delegate of 'T1 * 'T2 * 'T3 * 'T4 * 'T5 * 'T6 * 'T7 * 'T8 * 'T9 * 'T10 * 'T11 * 'T12 * 'T13 * 'T14 * 'T15 * 'T16 -> 'TResult"]]}""" + "\n" + """{"word":"Lazy","info":[["type Lazy<'T> =\n  new : unit -> Lazy<'T> + 5 overloads\n  member IsValueCreated : bool\n  member ToString : unit -> string\n  member Value : 'T"],["System.Lazy() : System.Lazy<'T>","System.Lazy(valueFactory: System.Func<'T>) : System.Lazy<'T>","System.Lazy(isThreadSafe: bool) : System.Lazy<'T>","System.Lazy(mode: System.Threading.LazyThreadSafetyMode) : System.Lazy<'T>","System.Lazy(valueFactory: System.Func<'T>, isThreadSafe: bool) : System.Lazy<'T>","System.Lazy(valueFactory: System.Func<'T>, mode: System.Threading.LazyThreadSafetyMode) : System.Lazy<'T>"]]}""" + "\n" + """{"word":"Converter","info":[["type Converter<'TInput,'TOutput> =\n  delegate of 'TInput -> 'TOutput"]]}"""
            "stderr","""{"word":"FormatProvider","info":[["property System.IO.TextWriter.FormatProvider: System.IFormatProvider"]]}""" + "\n" + """{"word":"Encoding","info":[["property System.IO.TextWriter.Encoding: System.Text.Encoding"]]}""" + "\n" + """{"word":"NewLine","info":[["property System.IO.TextWriter.NewLine: string"]]}""" + "\n" + """{"word":"Close","info":[["System.IO.TextWriter.Close() : unit"]]}""" + "\n" + """{"word":"CreateObjRef","info":[["System.MarshalByRefObject.CreateObjRef(requestedType: System.Type) : System.Runtime.Remoting.ObjRef"]]}""" + "\n" + """{"word":"Dispose","info":[["System.IO.TextWriter.Dispose() : unit"]]}""" + "\n" + """{"word":"Equals","info":[["System.Object.Equals(obj: obj) : bool"]]}""" + "\n" + """{"word":"Flush","info":[["System.IO.TextWriter.Flush() : unit"]]}""" + "\n" + """{"word":"FlushAsync","info":[["System.IO.TextWriter.FlushAsync() : System.Threading.Tasks.Task"]]}""" + "\n" + """{"word":"GetHashCode","info":[["System.Object.GetHashCode() : int"]]}""" + "\n" + """{"word":"GetLifetimeService","info":[["System.MarshalByRefObject.GetLifetimeService() : obj"]]}""" + "\n" + """{"word":"GetType","info":[["System.Object.GetType() : System.Type"]]}""" + "\n" + """{"word":"InitializeLifetimeService","info":[["System.MarshalByRefObject.InitializeLifetimeService() : obj"]]}""" + "\n" + """{"word":"ToString","info":[["System.Object.ToString() : string"]]}""" + "\n" + """{"word":"Write","info":[["System.IO.TextWriter.Write(value: obj) : unit","System.IO.TextWriter.Write(value: string) : unit","System.IO.TextWriter.Write(value: decimal) : unit","System.IO.TextWriter.Write(value: float) : unit","System.IO.TextWriter.Write(value: float32) : unit","System.IO.TextWriter.Write(value: uint64) : unit","System.IO.TextWriter.Write(value: int64) : unit","System.IO.TextWriter.Write(value: uint32) : unit","System.IO.TextWriter.Write(value: int) : unit","System.IO.TextWriter.Write(value: bool) : unit","System.IO.TextWriter.Write(buffer: char []) : unit","System.IO.TextWriter.Write(value: char) : unit","System.IO.TextWriter.Write(format: string, [<System.ParamArray>] arg: obj []) : unit","System.IO.TextWriter.Write(format: string, arg0: obj) : unit","System.IO.TextWriter.Write(format: string, arg0: obj, arg1: obj) : unit","System.IO.TextWriter.Write(buffer: char [], index: int, count: int) : unit","System.IO.TextWriter.Write(format: string, arg0: obj, arg1: obj, arg2: obj) : unit"]]}""" + "\n" + """{"word":"WriteAsync","info":[["System.IO.TextWriter.WriteAsync(buffer: char []) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteAsync(value: string) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteAsync(value: char) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteAsync(buffer: char [], index: int, count: int) : System.Threading.Tasks.Task"]]}""" + "\n" + """{"word":"WriteLine","info":[["System.IO.TextWriter.WriteLine() : unit","System.IO.TextWriter.WriteLine(value: obj) : unit","System.IO.TextWriter.WriteLine(value: string) : unit","System.IO.TextWriter.WriteLine(value: decimal) : unit","System.IO.TextWriter.WriteLine(value: float) : unit","System.IO.TextWriter.WriteLine(value: float32) : unit","System.IO.TextWriter.WriteLine(value: uint64) : unit","System.IO.TextWriter.WriteLine(value: int64) : unit","System.IO.TextWriter.WriteLine(value: uint32) : unit","System.IO.TextWriter.WriteLine(value: int) : unit","System.IO.TextWriter.WriteLine(value: bool) : unit","System.IO.TextWriter.WriteLine(buffer: char []) : unit","System.IO.TextWriter.WriteLine(value: char) : unit","System.IO.TextWriter.WriteLine(format: string, [<System.ParamArray>] arg: obj []) : unit","System.IO.TextWriter.WriteLine(format: string, arg0: obj) : unit","System.IO.TextWriter.WriteLine(format: string, arg0: obj, arg1: obj) : unit","System.IO.TextWriter.WriteLine(buffer: char [], index: int, count: int) : unit","System.IO.TextWriter.WriteLine(format: string, arg0: obj, arg1: obj, arg2: obj) : unit"]]}""" + "\n" + """{"word":"WriteLineAsync","info":[["System.IO.TextWriter.WriteLineAsync() : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(buffer: char []) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(value: string) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(value: char) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(buffer: char [], index: int, count: int) : System.Threading.Tasks.Task"]]}"""
            "stdin","""{"word":"Close","info":[["System.IO.TextReader.Close() : unit"]]}""" + "\n" + """{"word":"CreateObjRef","info":[["System.MarshalByRefObject.CreateObjRef(requestedType: System.Type) : System.Runtime.Remoting.ObjRef"]]}""" + "\n" + """{"word":"Dispose","info":[["System.IO.TextReader.Dispose() : unit"]]}""" + "\n" + """{"word":"Equals","info":[["System.Object.Equals(obj: obj) : bool"]]}""" + "\n" + """{"word":"GetHashCode","info":[["System.Object.GetHashCode() : int"]]}""" + "\n" + """{"word":"GetLifetimeService","info":[["System.MarshalByRefObject.GetLifetimeService() : obj"]]}""" + "\n" + """{"word":"GetType","info":[["System.Object.GetType() : System.Type"]]}""" + "\n" + """{"word":"InitializeLifetimeService","info":[["System.MarshalByRefObject.InitializeLifetimeService() : obj"]]}""" + "\n" + """{"word":"Peek","info":[["System.IO.TextReader.Peek() : int"]]}""" + "\n" + """{"word":"Read","info":[["System.IO.TextReader.Read() : int","System.IO.TextReader.Read(buffer: char [], index: int, count: int) : int"]]}""" + "\n" + """{"word":"ReadAsync","info":[["System.IO.TextReader.ReadAsync(buffer: char [], index: int, count: int) : System.Threading.Tasks.Task<int>"]]}""" + "\n" + """{"word":"ReadBlock","info":[["System.IO.TextReader.ReadBlock(buffer: char [], index: int, count: int) : int"]]}""" + "\n" + """{"word":"ReadBlockAsync","info":[["System.IO.TextReader.ReadBlockAsync(buffer: char [], index: int, count: int) : System.Threading.Tasks.Task<int>"]]}""" + "\n" + """{"word":"ReadLine","info":[["System.IO.TextReader.ReadLine() : string"]]}""" + "\n" + """{"word":"ReadLineAsync","info":[["System.IO.TextReader.ReadLineAsync() : System.Threading.Tasks.Task<string>"]]}""" + "\n" + """{"word":"ReadToEnd","info":[["System.IO.TextReader.ReadToEnd() : string"]]}""" + "\n" + """{"word":"ReadToEndAsync","info":[["System.IO.TextReader.ReadToEndAsync() : System.Threading.Tasks.Task<string>"]]}""" + "\n" + """{"word":"ToString","info":[["System.Object.ToString() : string"]]}"""
            "stdout","""{"word":"FormatProvider","info":[["property System.IO.TextWriter.FormatProvider: System.IFormatProvider"]]}""" + "\n" + """{"word":"Encoding","info":[["property System.IO.TextWriter.Encoding: System.Text.Encoding"]]}""" + "\n" + """{"word":"NewLine","info":[["property System.IO.TextWriter.NewLine: string"]]}""" + "\n" + """{"word":"Close","info":[["System.IO.TextWriter.Close() : unit"]]}""" + "\n" + """{"word":"CreateObjRef","info":[["System.MarshalByRefObject.CreateObjRef(requestedType: System.Type) : System.Runtime.Remoting.ObjRef"]]}""" + "\n" + """{"word":"Dispose","info":[["System.IO.TextWriter.Dispose() : unit"]]}""" + "\n" + """{"word":"Equals","info":[["System.Object.Equals(obj: obj) : bool"]]}""" + "\n" + """{"word":"Flush","info":[["System.IO.TextWriter.Flush() : unit"]]}""" + "\n" + """{"word":"FlushAsync","info":[["System.IO.TextWriter.FlushAsync() : System.Threading.Tasks.Task"]]}""" + "\n" + """{"word":"GetHashCode","info":[["System.Object.GetHashCode() : int"]]}""" + "\n" + """{"word":"GetLifetimeService","info":[["System.MarshalByRefObject.GetLifetimeService() : obj"]]}""" + "\n" + """{"word":"GetType","info":[["System.Object.GetType() : System.Type"]]}""" + "\n" + """{"word":"InitializeLifetimeService","info":[["System.MarshalByRefObject.InitializeLifetimeService() : obj"]]}""" + "\n" + """{"word":"ToString","info":[["System.Object.ToString() : string"]]}""" + "\n" + """{"word":"Write","info":[["System.IO.TextWriter.Write(value: obj) : unit","System.IO.TextWriter.Write(value: string) : unit","System.IO.TextWriter.Write(value: decimal) : unit","System.IO.TextWriter.Write(value: float) : unit","System.IO.TextWriter.Write(value: float32) : unit","System.IO.TextWriter.Write(value: uint64) : unit","System.IO.TextWriter.Write(value: int64) : unit","System.IO.TextWriter.Write(value: uint32) : unit","System.IO.TextWriter.Write(value: int) : unit","System.IO.TextWriter.Write(value: bool) : unit","System.IO.TextWriter.Write(buffer: char []) : unit","System.IO.TextWriter.Write(value: char) : unit","System.IO.TextWriter.Write(format: string, [<System.ParamArray>] arg: obj []) : unit","System.IO.TextWriter.Write(format: string, arg0: obj) : unit","System.IO.TextWriter.Write(format: string, arg0: obj, arg1: obj) : unit","System.IO.TextWriter.Write(buffer: char [], index: int, count: int) : unit","System.IO.TextWriter.Write(format: string, arg0: obj, arg1: obj, arg2: obj) : unit"]]}""" + "\n" + """{"word":"WriteAsync","info":[["System.IO.TextWriter.WriteAsync(buffer: char []) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteAsync(value: string) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteAsync(value: char) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteAsync(buffer: char [], index: int, count: int) : System.Threading.Tasks.Task"]]}""" + "\n" + """{"word":"WriteLine","info":[["System.IO.TextWriter.WriteLine() : unit","System.IO.TextWriter.WriteLine(value: obj) : unit","System.IO.TextWriter.WriteLine(value: string) : unit","System.IO.TextWriter.WriteLine(value: decimal) : unit","System.IO.TextWriter.WriteLine(value: float) : unit","System.IO.TextWriter.WriteLine(value: float32) : unit","System.IO.TextWriter.WriteLine(value: uint64) : unit","System.IO.TextWriter.WriteLine(value: int64) : unit","System.IO.TextWriter.WriteLine(value: uint32) : unit","System.IO.TextWriter.WriteLine(value: int) : unit","System.IO.TextWriter.WriteLine(value: bool) : unit","System.IO.TextWriter.WriteLine(buffer: char []) : unit","System.IO.TextWriter.WriteLine(value: char) : unit","System.IO.TextWriter.WriteLine(format: string, [<System.ParamArray>] arg: obj []) : unit","System.IO.TextWriter.WriteLine(format: string, arg0: obj) : unit","System.IO.TextWriter.WriteLine(format: string, arg0: obj, arg1: obj) : unit","System.IO.TextWriter.WriteLine(buffer: char [], index: int, count: int) : unit","System.IO.TextWriter.WriteLine(format: string, arg0: obj, arg1: obj, arg2: obj) : unit"]]}""" + "\n" + """{"word":"WriteLineAsync","info":[["System.IO.TextWriter.WriteLineAsync() : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(buffer: char []) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(value: string) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(value: char) : System.Threading.Tasks.Task","System.IO.TextWriter.WriteLineAsync(buffer: char [], index: int, count: int) : System.Threading.Tasks.Task"]]}"""
        ]

